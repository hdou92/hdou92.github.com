<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>渡</title>
  
  <subtitle>我有我的坚持,即使没有掌声也会不放弃。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2019-08-15T03:22:35.000Z</updated>
  <id>/</id>
  
  <author>
    <name>渡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java面试必备题库</title>
    <link href="/2019/08/07/java%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E9%A2%98%E5%BA%93/"/>
    <id>/2019/08/07/java面试必备题库/</id>
    <published>2019-08-07T15:58:39.000Z</published>
    <updated>2019-08-15T03:22:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><img src="/2019/08/07/java面试必备题库/javaLogo.jpg" alt="logo"></p><p>你还在为找不到工作烦恼？你还在为拿不到offer而夜不能寐？你还在为面试东奔西走而久久不得到认可？你还在为达不到你想要的薪资而纠结要不要去上班？何不停下脚步，看看下面的知识点你都会了？</p><p>最后愿程序猿梦里没有秃头，也没有改不完的BUG，阿里路亚~<a id="more"></a></p><h3 id="内容模块"><a href="#内容模块" class="headerlink" title="内容模块"></a>内容模块</h3><p>内容模块如下图所示:<br><img src="/2019/08/07/java面试必备题库/%E9%A2%98%E5%BA%93.jpg" alt="题库"></p><h3 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h3><blockquote><p><strong>首先来看一段代码</strong></p></blockquote><pre><code>public String method111() {    String ret = &quot;hello&quot;;    try {        return ret;    } finally {        ret = &quot;world&quot;;    }}</code></pre><ul><li><strong>最终返回什么呢？</strong><blockquote><p>最终返回什么呢？可能你知道，但是相信有一部分人是懵了的，因为我们都知道try-finally代码中finally模块最终一定会执行。下面咱们通过java字节码指令来看看到底发生了什么。<br>首先找到.class文件，然后执行<br>javap -verbose Test.class &gt;test.tx<br>然后保存到test.txt文件中</p></blockquote></li></ul><pre><code> public java.lang.String method111();    descriptor: ()Ljava/lang/String;    flags: ACC_PUBLIC    Code:      stack=1, locals=4, args_size=1        0: ldc           #2 //把常量池中的常量压到操作数栈里// String hello        2: astore_1      //然后存到本地变量1中         3: aload_1       //加载本地变量1到操作数栈         4: astore_2      //再把它保存到本地变量2中         5: ldc           #3 //把常量池中的常量压到操作数栈里// String world        7: astore_1      //然后存到本地变量1中         8: aload_2       //加载本地变量2到操作数栈         9: areturn       //返回栈里的数据 hello 因为本地变量保存的是hello        10: astore_3        11: ldc           #3                  // String world        13: astore_1        14: aload_3        15: athrow      Exception table:         from    to  target type             3     5    10   any      LineNumberTable:        line 7: 0        line 9: 3        line 11: 5        line 9: 8        line 11: 10      LocalVariableTable:        Start  Length  Slot  Name   Signature            0      16     0  this   Lcom/u2jinfu/com/requestbank/controller/Test;3      13     1   ret   Ljava/lang/String;.....其他部分省略</code></pre><blockquote><p>由字节码指令可以看出，显示把hello保存到本地变1和本地变量2中。后面返回的是本地变量2，所以返回的就是hello，通过现象看本质。</p></blockquote><ul><li><strong>JDK 和 JRE 有什么区别？</strong><blockquote><p>JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。<br>JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。<br>具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。</p></blockquote></li></ul><ul><li><strong>new一个对象在Java内部做了哪些工作？</strong><blockquote><p>从静态角度来看，new一个对象表示创建一个类的对象实例。<br>从JVM运行角度来看，当JVM执行到new字节码时，首先会去查看类有没有被加载到内存以及初始化，如果是第一次使用该类，则首先加载该类。加载完成后便会在堆内存分配该对象实例的内存空间，虚拟机栈分配对象实例的应用内存。</p></blockquote></li></ul><ul><li><strong>final 在 Java 中有什么作用？</strong><blockquote><p>final 修饰的类叫最终类，该类不能被继承。<br>final 修饰的方法不能被重写。<br>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p></blockquote></li></ul><ul><li><strong>抽象类是否可以定义构造函数？如果能，是否能new一个抽象类？</strong><blockquote><p>抽象类同样也可以定义构造函数，但是它不能new一个抽象类。</p></blockquote></li></ul><ul><li><strong>既然不能new一个抽象类，那它定义构造函数有什么意义呢？</strong><blockquote><p>抽象类中的构造函数只能通过构造函数链调用，也就是从其他类中的构造函数调用，它的作用可以初始化抽象类中的一些初始值。</p></blockquote></li></ul><ul><li><strong>String是否是基本数据类型？它与StringBuilder、StringBuffer有什么区别？</strong><blockquote><p>String不是基本数据类型。<br>String是不可变的，尽管它能在程序中多次赋值以及拼接，但实际上每一次赋值都是在内存中重新开辟一块内存空间。<br>StringBuilder和StringBuffer是可变的，多次对它们赋值不会在内存中开辟一块内存空间，StringBuilder不是线程安全，StringBuffer是线程安全的。</p></blockquote></li></ul><ul><li><strong>StringBuilder与StringBuffer的内部实现原理是什么？</strong><blockquote><p>StringBuffer与StringBuilder的不同点在于StringBuffer在append方法加了synchronized关键字，它是线程安全的。<br>它们都是继承自AbstractBuilder，内部实现都是一个可变数组，数组初始长度为16。当调用append方法拼接字符串时，其内部实际上是调用了System.arraycopy将字符串拷贝进了可变数组。</p></blockquote></li></ul><ul><li><strong>StringBuilder的扩容机制是什么？</strong><blockquote><p>StringBuilder在内部是一个字符数组，默认大小为16，当容量超过16时，会进行扩容，新的数组大小是之前数组大小的2倍+2，也就是第一次扩容大小为34。扩容后将以前的数组拷贝到新数组中。</p></blockquote></li></ul><ul><li><strong>String str = “a”与String str = new String(“b”)有什么区别？</strong><blockquote><p>String str = “a”，首先会去常量池中查找是否有”a”字符串，如果有则直接指向它，没有则在常量池中创建并指向它。<br>String str = new String(“b”)则会在堆内存中创建一个String对象实例，并指向它，同时它也会在常量池中创建”b”对象。</p></blockquote></li></ul><ul><li><strong>String str=”i”与 String str=new String(“i”)一样吗？</strong><blockquote><p>不一样，因为内存的分配方式不一样。String str=“i”的方式，Java 虚拟机会将其分配到常量池中，如果常量池中有”i”，就返回”i”的地址，如果没有就创建”i”，然后返回”i”的地址；而 String str=new String(“i”) 则会被分到堆内存中新开辟一块空间。</p></blockquote></li></ul><ul><li><strong>如何将字符串反转？</strong><blockquote><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。<br>示例代码：<br>   StringBuffer stringBuffer = new StringBuffer();<br>   stringBuffer. append(“abcdefg”);<br>   System. out. println(stringBuffer. reverse()); // gfedcba</p></blockquote></li></ul><ul><li><strong>String 类的常用方法都有那些？</strong><blockquote><p>indexOf()：返回指定字符的索引。<br>charAt()：返回指定索引处的字符。<br>replace()：字符串替换。<br>trim()：去除字符串两端空白。<br>split()：分割字符串，返回一个分割后的字符串数组。<br>getBytes()：返回字符串的 byte 类型数组。<br>length()：返回字符串长度。<br>toLowerCase()：将字符串转成小写字母。<br>toUpperCase()：将字符串转成大写字符。<br>substring()：截取字符串。<br>equals()：字符串比较。</p></blockquote></li></ul><ul><li><strong>==与equals比较有什么区别？</strong><blockquote><p>==比较的是引用地址，对于基本类型和引用类型 == 的作用效果是不同的,基本类型：比较的是值是否相同；引用类型：比较的是引用是否相同；<br>equals通常比较的是值，equals在Object中的实现仍然是==，所以如果要通过equals比较值就必须重写equals。</p></blockquote></li></ul><ul><li><strong>重写equals方法需要注意什么？</strong><blockquote><p>在重写equals方法时，一定要重写hashCode方法，hashCode方法是计算对象的hash值。<br>在Java中规定：<br>equals等于true，则它们的hashCode一定相等；<br>equals等于false，则它们的hashCode可能相等可能不相等，也就是如果hashCode相等，则equals不一定相等。<br>之所以要重写hashCode方法，主要是应用在集合中的判断。<br>如果没有重写类的hashCode方法，只重写了equals方法，当两个对象equals等于true时，它们的hashCode不相等。此时如果将它们作为key放到Map集合中，由于它们的hash值不相等，所以Map认为它们是不相等的key，此时在Map中将会在逻辑上存在两个相等的key值，不符合我们对程序的预期。所以在重写equals方法时必须重写hashCode方法。</p></blockquote></li></ul><ul><li><strong>重写hashCode方法需要注意什么？</strong><blockquote><p>在设计散列函数时，应该尽量避免冲突。如果频繁的产生散列冲突，在将对象作为key存放在Map中时，会将不同的key值散列到一个位置，对Map的性能会有所影响。可以参考String的hashCode实现，将质数31数字作为乘法因子。</p></blockquote></li></ul><ul><li><strong>Java 中的 Math. round(-1. 5) 等于多少？</strong><blockquote><p>等于 -1。round()是四舍五入，注意负数5是舍的，例如：Math.round(1.5)值是2，Math.round(-1.5)值是-1。</p></blockquote></li></ul><ul><li><strong>Java 中 IO 流分为几种？</strong><blockquote><p>按功能来分：输入流（input）、输出流（output）。<br>按类型来分：字节流和字符流。<br>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p></blockquote></li></ul><ul><li><strong>BIO、NIO、AIO 有什么区别？</strong><blockquote><p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。<br>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。<br>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p></blockquote></li></ul><ul><li><strong>Files的常用方法都有哪些？</strong><blockquote><p>Files. exists()：检测文件路径是否存在。<br>Files. createFile()：创建文件。<br>Files. createDirectory()：创建文件夹。<br>Files. delete()：删除一个文件或目录。<br>Files. copy()：复制文件。<br>Files. move()：移动文件。<br>Files. size()：查看文件个数。<br>Files. read()：读取文件。<br>Files. write()：写入文件。</p></blockquote></li></ul><h4 id="java-集合、容器"><a href="#java-集合、容器" class="headerlink" title="java 集合、容器"></a>java 集合、容器</h4><ul><li><strong>Java 容器都有哪些？</strong><blockquote><p>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如:Collection、List、ArrayList、LinkedList、Vector、Stack、Set、HashSet、LinkedHashSet、TreeSet、Map、HashMap、LinkedHashMap、TreeMap、ConcurrentHashMap、Hashtable。</p></blockquote></li></ul><ul><li><strong>Collection 和 Collections 有什么区别？</strong><blockquote><p>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。<br>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。</p></blockquote></li></ul><ul><li><strong>List、Set、Map 之间的区别是什么？</strong><blockquote><p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。</p></blockquote></li></ul><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><ul><li><strong>HashMap的内部实现原理是什么？</strong><blockquote><p>HashMap内部实现原理是数组+链表，通过散列算法将key值散列到数组中，如果到相同的位置，则通过拉链法解决散列冲突。在JDK8中新增了红黑树结构，当HashMap中的散列冲突链表结构超过8个数据时，会从链表结构转换为红黑树结构。</p></blockquote></li></ul><ul><li><strong>HashMap的key值能否是null，如果能，key=null如何存储以及如何读取的？如果不能，为什么？</strong><blockquote><p>HashMap的key值可以是null。如果key=null，则会将它放置在数组下标为0的位置。</p></blockquote></li></ul><ul><li><strong>HashMap如何实现扩容？</strong><blockquote><p>HashMap扩容和初始容器大小与负载因子有关。HashMap的初始容器大小为16，默认的负载因子为0.75，当实际容量超过16*0.75=12个元素时会进行扩容。扩容后的容器大小是扩容前的2倍，第一次扩容后的容器大小为32。</p></blockquote></li></ul><ul><li><strong>设置HashMap的容量有没有注意的地方，为什么？</strong><blockquote><p>指定HashMap的容量时，建议是2的幂次方。<br>HashMap在寻址是会key的hash值与容器长度做与运算，(n - 1) &amp; hash。当n的长度为2的幂次方时，n-1的二进制形式就会是111111，这样与操作效率会非常的快。</p></blockquote></li></ul><ul><li><strong>HashMap是否是线程安全的？如果不是，多线程下并发操作它可能会带来什么问题？如果是，它是怎么实现的？</strong><blockquote><p>HashMap不是线程安全的。如果在多线程下并发操作不仅会导致脏数据，甚至可能会造成死循环。（关于死循环产生的原因参考<a href="https://www.cnblogs.com/yulinfeng/p/8558983.html）" target="_blank" rel="noopener">https://www.cnblogs.com/yulinfeng/p/8558983.html）</a></p></blockquote></li></ul><ul><li><strong>LinkedHashMap的内部实现原理是什么？它是否支持key=null？</strong><blockquote><p>LinkedHashMap是插入有序的Map集合。它直接继承了HashMap，所以很多都直接复用了HashMap方法，所以也支持key=null。它在内部除了沿用HashMap的底层结构，还单独维护了一个双向链表，在对Map进行put操作时，同时还会将数据写到了链表的尾部，保证了插入有序。</p></blockquote></li></ul><ul><li><strong>TreeMap的内部实现原理是什么？它是否支持key=null？</strong><blockquote><p>TreeMap结构也是有序的，不同的是它是字典有序，由于它底层是红黑树结构，插入时会进行比较key值的顺序，所以不允许key=null的情况。</p></blockquote></li></ul><ul><li><strong>介绍下Hashtable</strong><blockquote><p>Hashtable是线程安全的Map类型，但它的线程安全代价是为整个散列表加锁，效率很低，几乎已经废弃。如果要使用线程安全的Map，应该使用ConcurrentHashMap，它的实现是分段锁，能最大的提高效率。</p></blockquote></li></ul><ul><li><strong>以上三种Map类型分别可以应用到哪些场景？你在哪些场景下使用过？</strong><blockquote><p>HashMap的使用场景很多，这个使用场景就太多了，比如用作本地缓存。<br>LinkedHashMap因为它的链表结构可以实现LRU（最近最少使用），即缓存空间有限，当元素多余缓存空间，可淘汰掉最近最少使用的元素。在LinkedHashMap维护了一个accessOrder字段，默认为false，当设置为true时，如果访问一个key值，就会将这个元素放置链表头部，这样在链表尾部的元素就是不常用的元素，空间不足直接remove末尾的元素即可。所以当要实现LRU缓存时，就可以将accessOrder设置为true实现。<br>TreeMap没有实际应用过，如果有需要排序的场景则使用TreeMap</p></blockquote></li></ul><ul><li><strong>HashMap 和 Hashtable 有什么区别？</strong><blockquote><p>HashMap是继承自AbstractMap类，而HashTable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口。<br>Hashtable比HashMap多提供了elments() 和contains() 两个方法。<br>HashMap的key-value支持key-value，null-null，key-null，null-value四种。而Hashtable只支持key-value一种（即key和value都不为null这种形式）。既然HashMap支持带有null的形式，那么在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断，因为使用get的时候，当返回null时，你无法判断到底是不存在这个key，还是这个key就是null，还是key存在但value是null。<br>线程安全性不同：HashMap的方法都没有使用synchronized关键字修饰，都是非线程安全的，而Hashtable的方法几乎都是被synchronized关键字修饰的。但是，当我们需要HashMap是线程安全的时，怎么办呢？我们可以通过Collections.synchronizedMap(hashMap)来进行处理，亦或者我们使用线程安全的ConcurrentHashMap。ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。<br>初始容量大小和每次扩充容量大小的不同：Hashtable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。<br>计算hash值的方法不同：为了得到元素的位置，首先需要根据元素的 KEY计算出一个hash值，然后再用这个hash值来计算得到最终的位置。Hashtable直接使用对象的hashCode。hashCode是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。然后再使用除留余数发来获得最终的位置。</p></blockquote></li></ul><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><ul><li><strong>HashSet的内部实现原理是什么，它有什么特点？</strong><blockquote><p>HashSet集合的特点是不允许有重复的元素，且无序的，允许null值。HashSet 是基于 HashMap 实现的，它在内部维护一个HashMap，存储在HashSet中的元素实际上存储在HashMap的key中,因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成。</p></blockquote></li></ul><ul><li><strong>LinkedHashSet的内部实现原理是什么，它有什么特点？</strong><blockquote><p>LinkedHashSet继承自HashMap，在内部维护一个双向链表保证插入有序，允许null值。</p></blockquote></li></ul><ul><li><strong>TreeSet的内部实现原理是什么，它有什么特点？</strong><blockquote><p>TreeSet是一个有序的集合，它的作用是提供有序的Set集合，TreeSet是基于TreeMap实现的。不允许有null值。</p></blockquote></li></ul><ul><li><strong>以上三种Set类型分别可以应用到哪些场景？你在哪些场景下使用过？</strong><blockquote><p>HashSet可应用于批量查询时去重。<br>如果需要返回的数据和入参的数据顺序一致则可以使用LinkedHashSet。</p></blockquote></li></ul><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><ul><li><strong>ArrayList的内部实现原理什么？</strong><blockquote><p>底层通过数组实现，创建一个ArrayList对象实例时不会初始化数组，当插入第一条数据时会创建一个大小为10的数组。</p></blockquote></li></ul><ul><li><strong>既然ArrayList的底层实现是数组，那定义ArrayList时，需要定义它的大小吗？</strong><blockquote><p>可以不用定义容器的大小，默认大小为10，当容量大小不足时此时将会进行扩容。</p></blockquote></li></ul><ul><li><strong>ArrayList的扩容机制是什么？</strong><blockquote><p>每次新增的容量是旧容量的一半，扩容后调用System.arraycopy方法拷贝到新的数组。</p></blockquote></li></ul><ul><li><strong>如果初始化ArrayList时，定义一个容量大小为11，此时扩容了几次，容量大小为16呢？</strong><blockquote><p>不进行扩容。</p></blockquote></li></ul><ul><li><strong>LinkedList的内部实现原理是什么？</strong><blockquote><p>底层通过链表实现，所以不存在扩容。</p></blockquote></li></ul><ul><li><strong>Vector和ArrayList、LinkedList的区别？</strong><blockquote><p>Vector是线程安全的额，ArrayList、LinkedList不是线程安全的。Vector的线程安全是为每个方法加上synchronized关键字，效率不高，不常用。</p></blockquote></li></ul><ul><li><strong>ArrayList与LinkedList分别可以应用到哪些场景？</strong><blockquote><p>大多数情况下使用ArrayList，因为ArrayList是数组实现，它随机读取的速度更快，但插入指定位置慢；LinkedList由于是链表实现，所以随机读取的速度慢，但插入指定位置快。</p></blockquote></li></ul><ul><li><strong>ArrayList 和 LinkedList 的区别是什么？</strong><blockquote><p>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。<br>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。<br>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。<br>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p></blockquote></li></ul><ul><li><strong>如何实现数组和 List 之间的转换？</strong><blockquote><p>数组转 List：使用 Arrays. asList(array) 进行转换。<br>List 转数组：使用 List 自带的 toArray() 方法。</p></blockquote></li></ul><ul><li><strong>ArrayList 和 Vector 的区别是什么？</strong><blockquote><p>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。<br>性能：ArrayList 在性能方面要优于 Vector。<br>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</p></blockquote></li></ul><ul><li><strong>Array 和 ArrayList 有何区别？</strong><blockquote><p>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。<br>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。<br>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</p></blockquote></li></ul><ul><li><strong>在 Queue 中 poll()和 remove()有什么区别？</strong><blockquote><p>相同点：都是返回第一个元素，并在队列中删除返回的对象。<br>不同点：如果没有元素 remove()会直接抛出NoSuchElementException 异常，而 poll()会返回 null。</p></blockquote></li></ul><ul><li><strong>哪些集合类是线程安全的？</strong><blockquote><p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p></blockquote></li></ul><ul><li><strong>迭代器 Iterator 是什么？</strong><blockquote><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p></blockquote></li></ul><ul><li><strong>Iterator的特点是什么？</strong><blockquote><p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p></blockquote></li></ul><ul><li><strong>Iterator 和 ListIterator 有什么区别？</strong><blockquote><p>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。<br>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。<br>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p></blockquote></li></ul><ul><li><strong>怎么确保一个集合不能被修改？</strong><blockquote><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p></blockquote></li></ul><h4 id="Java-多线程"><a href="#Java-多线程" class="headerlink" title="Java 多线程"></a>Java 多线程</h4><ul><li><strong>并行和并发有什么区别？</strong><blockquote><p>并行：多个处理器或多核处理器同时处理多个任务。<br>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</p></blockquote></li></ul><ul><li><strong>线程和进程的区别？</strong><blockquote><p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p></blockquote></li></ul><ul><li><strong>直接new一个线程会有什么问题？</strong><blockquote><p>每次都new一个线程性能较差；线程缺乏统一的管理；缺乏定时执行等功能。所以应该使用线程池来管理线程。</p></blockquote></li></ul><ul><li><strong>守护线程是什么？</strong><blockquote><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p></blockquote></li></ul><ul><li><strong>多线程有几种实现方式？</strong><blockquote><p>有4种，分别是：<br>继承Thread类<br>实现Runnable接口<br>实现Callable接口通过FutureTask包装器来创建Thread线程<br>通过线程池创建线程，使用线程池接口ExecutorService结合Callable、Future实现有返回结果的多线程。<br>前面两种【无返回值】原因：通过重写run方法，run方法的返回值是void，所以没有办法返回结果。<br>后面两种【有返回值】原因：通过Callable接口，就要实现call方法，这个方法的返回值是Object，所以返回的结果可以放在Object对象中。</p></blockquote></li></ul><ul><li><strong>说一下 Runnable和 Callable有什么区别？</strong><blockquote><p>Runnable没有返回值，Callable可以拿到有返回值，Callable可以看作是 Runnable的补充。</p></blockquote></li></ul><ul><li><strong>线程有哪些状态？</strong><blockquote><p>线程的6种状态：<br>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。<br>运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。<br>阻塞(BLOCKED)：表示线程阻塞于锁。<br>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。<br>超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。<br>终止(TERMINATED)：表示该线程已经执行完毕。</p></blockquote></li></ul><ul><li><strong>sleep() 和 wait() 有什么区别？</strong><blockquote><p>类的不同：sleep() 来自 Thread，wait() 来自 Object。<br>释放锁：sleep() 不释放锁；wait() 释放锁。<br>用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。</p></blockquote></li></ul><ul><li><strong>notify()和 notifyAll()有什么区别？</strong><blockquote><p>notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p></blockquote></li></ul><ul><li><strong>wait、notify、notifyAll明明是和线程相关，为什么不在Thread而在Object类中呢？</strong><blockquote><p>因为Java提供给线程的锁，是在每个对象上的对象监视器锁，所以在唤醒、等待锁的时候，是对对象锁的操作，并不是对线程的操作。</p></blockquote></li></ul><ul><li><strong>interrupted 和 isInterrupted方法有什么区别？</strong><blockquote><p>调用线程的interrupt()会中断一个线程（将线程的中断标志位设置为true），调用interrupted方法会将中断标志位清除，调用isInterrupted方法不会将中断标志位清除。</p></blockquote></li></ul><ul><li><strong>线程的 run() 和 start() 有什么区别？</strong><blockquote><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p></blockquote></li></ul><ul><li><strong>yield方法有什么作用？</strong><blockquote><p>yield称为让步，表示当前线程让出CPU资源，和其他线程再次竞争资源，但有可能让步后又重新执行</p></blockquote></li></ul><ul><li><strong>什么是ThreadLocal变量？</strong><blockquote><p>ThreadLocal是一个线程的本地化对象。ThreadLocal为每个使用该变量的线程分配一个独立的副本。线程与线程本身是共享变量的，但是ThreadLocal可以使得变量在线程中独占，从而避免线程安全问题。例如在Spring中的bean通常是单例的，通过ThreadLocal进行封装，就能使bean在多线程环境中线程安全。</p></blockquote></li></ul><ul><li><strong>ThreadLocal的实现原理？</strong><blockquote><p>ThreadLocal内部维护一个ThreadLocalMap结构，类似HashMap，在ThreadLocalMap中又定义了一个Entry结构用于存储key-value。</p></blockquote></li></ul><ul><li><strong>ThreadLocal可能会导致什么问题？</strong><blockquote><p>ThreadLocal可能会导致内存溢出。<br>关于ThreadLocal需要深刻体会，建议多查资料理解</p></blockquote></li></ul><ul><li><strong>CountDownLatch、CyclicBarrier有什么区别？</strong><blockquote><p>CountDownLatch称为闭锁，当一个任务需要其他线程执行完成才能执行时可以使用CountDownLatch，其他线程执行完成过后调用CountDownLatch.countDown，内部计数器-1，等待的任务调用CountDownLatch.await方法，当CountDownLatch内部计数器减少为0时，等待的任务被唤醒。<br>CyclicBarrier称为栅栏，和CountDownLatch类似，也是为了等待其他线程。CyclicBarrier是为了配合其他线程同时到达某处时才再执行。</p></blockquote></li></ul><ul><li><strong>Java提供了哪几种线程池？</strong><blockquote><p>Java提供了4种线程池：<br>newFixedThreadPool：固定线程池，线程池的线程数量是固定的；<br>newSingleThreadPool：只包含一个线程的线程池；<br>newCachedThreadPool：可创建“无限量”线程的线程池；<br>newScheduledThreadPool：可以定时执行任务的线程池。</p></blockquote></li></ul><ul><li><strong>线程池的原理？</strong><blockquote><p>上面四种线程池本质上都是调用ThreadPoolExecutor实现，ThreadPoolExecutor有4个核心参数：核心线程池、任务队列、最大线程池、饱和策略。<br>核心线程池中的线程在任务执行完成后并不会被销毁回收（这有利于提高响应速度），但在创建线程池的时候也并不会创建线程，而是等待任务到底时并没有空闲线程才会创建（这是懒汉模式，最大限度不浪费资源）。<br>工作队列指的是当核心线程池中的线程都在执行任务，并没有多余的线程，此时会将任务放到队列中等待执行。<br>最大线程池指的是在这个线程池中允许存在的线程数量，当核心线程池满，工作队列恰好也是有界队列并且也满，此时可创建“临时”线程，临时线程可创建的数量就是最大线程池-核心线程池，它在执行完任务后会在指定的时间销毁。<br>饱和策略指的是核心线程池满，工作队列也满，可允许创建的临时线程池也满，此时仍然有任务被提交到线程池时应该执行什么样的策略。<br>结合上述线程池底层实现的术语，线程池的处理流程如下所示：<br>提交一个任务到线程池，首先判断核心线程池是否已满，没有满则创建线程执行任务，已满则进行下一步；<br>任务提交到工作队列，判断工作队列是否已满，没有满则将任务放到队列中等待执行，已满则进行下一步；<br>前两步中核心线程池、工作队列均已满，此时将会判断是否创建新的“临时”线程，如果当前池中的线程总数小于“最大线程池”数量，则创建新的线程执行任务，没有则进入饱和策略。</p></blockquote></li></ul><ul><li><strong>创建线程池有哪几种方式？</strong><blockquote><p>线程池创建有七种方式，最核心的是最后一种：<br>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；<br>newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；<br>newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；<br>newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；<br>newScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；<br>newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；<br>ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。</p></blockquote></li></ul><ul><li><strong>线程池都有哪些状态？</strong><blockquote><p>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。<br>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。<br>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。<br>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。<br>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</p></blockquote></li></ul><ul><li><strong>线程池中 submit() 和 execute() 方法有什么区别？</strong><blockquote><p>execute()：只能执行 Runnable 类型的任务。<br>submit()：可以执行 Runnable 和 Callable 类型的任务。<br>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p></blockquote></li></ul><ul><li><strong>线程池中的工作队列如果选择无界队列会有什么问题？</strong><blockquote><p>如果使用无界队列，将导致线程池中只有核心线程池在工作，无法创建更多的线程池，实际上“最大线程池”参数没有用，随着任务的不断增加，工作队列中的任务越来越多，直至内存消耗完OOM。</p></blockquote></li></ul><ul><li><strong>线程池有哪些饱和策略？</strong><blockquote><p>当任务队列中已满，且线程池也满的情况。将会触发线程池的饱和策略。线程池中的饱和策略一共有四种：<br>AbortPolicy：抛出RejectedExecutionException异常；<br>DiscardOldestPolicy：将抛弃任务队列中最旧未处理的任务，也就是最后一条任务；<br>DiscardPolicy：直接抛弃新的任务；<br>CallerRunsPolicy：不做任何处理，将任务返回给调用者。</p></blockquote></li></ul><ul><li><strong>如何确定线程池中线程的数量？</strong><blockquote><p>线程池中的线程数量并不是越多越好，线程过多，线程的上下文切换耗时更多，性能可能更差。应结合任何类型和CPU情况综合确定线程池中线程的数量。在《Java并发编程实战》书中作者的建议，<br>假设服务器有N个CPU：<br>如果是CPU计算密集型任务，线程池中的线程大小设置为N+1，对于计算密集型的任务使用CPU的频率较高，应尽量减少线程的上下文切换，故线程数不宜过多。<br>如果是IO密集型任务，线程池中的线程大小设置为2N+1，IO密集型任务因为对CPU的使用频率不高，可以利用CPU在的等待IO时去处理其他的任务，所以可以设置叫大的线程数量。</p></blockquote></li></ul><ul><li><strong>如何处理线程池中线程产生异常的情况？</strong><blockquote><p>在多线程环境下，线程中的异常不能通过trycatch来捕获处理。通过调用线程的setUncaughtExceptionHandler方法处理未捕获异常造成的线程中断。</p></blockquote></li></ul><ul><li><strong>什么是线程泄露？如何解决线程泄露？</strong><blockquote><p>因为线程产生异常未被捕获，导致线程死亡，线程池中可用的线程越来越少，称为线程泄露。捕获异常，当线程发生错误时，重启线程。</p></blockquote></li></ul><ul><li><strong>在 Java 程序中怎么保证多线程的运行安全？</strong><blockquote><p>方法一：使用安全类，比如 Java. util. concurrent 下的类。<br>方法二：使用自动锁 synchronized。<br>方法三：使用手动锁 Lock。<br>手动锁 Java 示例代码如下：<br>  Lock lock = new ReentrantLock();<br>  lock. lock();<br>  try {<br>  System. out. println(“获得锁”);<br>  } catch (Exception e) {<br>  // TODO: handle exception<br>  } finally {<br>  System. out. println(“释放锁”);<br>  lock. unlock();<br>   }</p></blockquote></li></ul><ul><li><strong>多线程中 synchronized 锁升级的原理是什么？</strong><blockquote><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。<br>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p></blockquote></li></ul><ul><li><strong>什么是死锁？</strong><blockquote><p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p></blockquote></li></ul><ul><li><strong>怎么防止死锁？</strong><blockquote><p>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。<br>尽量使用 Java. util. concurrent 并发类代替自己手写锁。<br>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。<br>尽量减少同步的代码块。</p></blockquote></li></ul><ul><li><strong>ThreadLocal 是什么？有哪些使用场景？</strong><blockquote><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。<br>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p></blockquote></li></ul><ul><li><strong>说一下 synchronized 底层实现原理？</strong><blockquote><p>synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p></blockquote></li></ul><ul><li><strong>synchronized 和 volatile 的区别是什么？</strong><blockquote><p>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。<br>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。<br>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</p></blockquote></li></ul><ul><li><strong>synchronized 和 Lock 有什么区别？</strong><blockquote><p>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。<br>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。<br>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p></blockquote></li></ul><ul><li><strong>synchronized 和 ReentrantLock 区别是什么？</strong><blockquote><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。<br>主要区别如下：<br>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；<br>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；<br>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。<br>ReentrantLock 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</p></blockquote></li></ul><ul><li><strong>说一下 atomic 的原理？</strong><blockquote><p>atomic 主要利用 CAS (Compare And Swap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p></blockquote></li></ul><h4 id="Java-反射"><a href="#Java-反射" class="headerlink" title="Java 反射"></a>Java 反射</h4><ul><li><strong>什么是反射？</strong><blockquote><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p></blockquote></li></ul><ul><li><strong>什么是 Java 序列化？什么情况下需要序列化？</strong><blockquote><p>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。<br>以下情况需要使用 Java 序列化：<br>想把的内存中的对象状态保存到一个文件中或者数据库中时候；<br>想用套接字在网络上传送对象的时候；<br>想通过RMI（远程方法调用）传输对象的时候。</p></blockquote></li></ul><ul><li><strong>动态代理是什么？有哪些应用？</strong><blockquote><p>动态代理是运行时动态生成代理类。<br>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</p></blockquote></li></ul><ul><li><strong>怎么实现动态代理？</strong><blockquote><p>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</p></blockquote></li></ul><h4 id="Java-对象拷贝"><a href="#Java-对象拷贝" class="headerlink" title="Java 对象拷贝"></a>Java 对象拷贝</h4><ul><li><strong>为什么要使用克隆？</strong><blockquote><p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</p></blockquote></li></ul><ul><li><strong>如何实现对象克隆？</strong><blockquote><p>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。<br>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</p></blockquote></li></ul><ul><li><strong>深拷贝和浅拷贝区别是什么？</strong><blockquote><p>浅拷贝：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。<br>深拷贝：除了对象本身被复制外，对象所包含的所有成员变量也将复制。</p></blockquote></li></ul><h4 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h4><ul><li><strong>JSP 和 servlet 有什么区别？</strong><blockquote><p>JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑。</p></blockquote></li></ul><ul><li><strong>JSP 有哪些内置对象？作用分别是什么？</strong><blockquote><p>JSP 有 9 大内置对象：<br>request：封装客户端的请求，其中包含来自 get 或 post 请求的参数；<br>response：封装服务器对客户端的响应；<br>pageContext：通过该对象可以获取其他对象；<br>session：封装用户会话的对象；<br>application：封装服务器运行环境的对象；<br>out：输出服务器响应的输出流对象；<br>config：Web 应用的配置对象；<br>page：JSP 页面本身（相当于 Java 程序中的 this）；<br>exception：封装页面抛出异常的对象。</p></blockquote></li></ul><ul><li><strong>说一下 JSP 的 4 种作用域？</strong><blockquote><p>page：代表与一个页面相关的对象和属性。<br>request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。<br>session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。<br>application：代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。</p></blockquote></li></ul><ul><li><strong>session 和 cookie 有什么区别？</strong><blockquote><p>session：是一种将会话状态保存在服务器端的技术。<br>Cookie ：是在 HTTP 协议下， Web 服务器保存在用户浏览器（客户端）上的小文本文件，它可以包含有关用户的信息。无论何时用户链接到服务器，Web 站点都可以访问 Cookie 信息 。<br>存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。<br>安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。<br>容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。<br>存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。</p></blockquote></li></ul><ul><li><strong>说一下 session 的工作原理？</strong><blockquote><p>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。</p></blockquote></li></ul><ul><li><strong>如果客户端禁止 cookie 能实现 session 还能用吗？</strong><blockquote><p>可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加 sessionid 的方式保证 session 能正常使用。</p></blockquote></li></ul><ul><li><strong>spring mvc 和 struts 的区别是什么？</strong><blockquote><p>拦截级别：struts2 是类级别的拦截；spring mvc 是方法级别的拦截。<br>数据独立性：spring mvc 的方法之间基本上独立的，独享 request 和 response 数据，请求数据通过参数获取，处理结果通过 ModelMap 交回给框架，方法之间不共享变量；而 struts2 虽然方法之间也是独立的，但其所有 action 变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦。<br>拦截机制：struts2 有以自己的 interceptor 机制，spring mvc 用的是独立的 aop 方式，这样导致struts2 的配置文件量比 spring mvc 大。<br>对 ajax 的支持：spring mvc 集成了ajax，所有 ajax 使用很方便，只需要一个注解 @ResponseBody 就可以实现了；而 struts2 一般需要安装插件或者自己写代码才行。</p></blockquote></li></ul><ul><li><strong>如何避免 SQL 注入？</strong><blockquote><p>使用预处理 PreparedStatement。<br>使用正则表达式过滤掉字符中的特殊字符。</p></blockquote></li></ul><ul><li><strong>什么是 XSS 攻击，如何避免？</strong><blockquote><p>XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。<br>预防 XSS 的核心是必须对输入的数据做过滤处理。</p></blockquote></li></ul><ul><li><strong>什么是 CSRF 攻击，如何避免？</strong><blockquote><p>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。<br>防御手段：<br>验证请求来源地址；<br>关键操作添加验证码；<br>在请求地址添加 token 并验证。</p></blockquote></li></ul><h4 id="Java-异常"><a href="#Java-异常" class="headerlink" title="Java 异常"></a>Java 异常</h4><ul><li><strong>throw 和 throws 的区别？</strong><blockquote><p>throw：是真实抛出一个异常。<br>throws：是声明可能会抛出一个异常。</p></blockquote></li></ul><ul><li><strong>final、finally、finalize 有什么区别？</strong><blockquote><p>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。<br>finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。<br>finalize： 是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。</p></blockquote></li></ul><ul><li><strong>try-catch-finally 中哪个部分可以省略？</strong><blockquote><p>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</p></blockquote></li></ul><ul><li><strong>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</strong><blockquote><p>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p></blockquote></li></ul><ul><li><strong>常见的异常类有哪些？</strong><blockquote><p>NullPointerException 空指针异常<br>ClassNotFoundException 指定类不存在<br>NumberFormatException 字符串转换为数字异常<br>IndexOutOfBoundsException 数组下标越界异常<br>ClassCastException 数据类型转换异常<br>FileNotFoundException 文件未找到异常<br>NoSuchMethodException 方法不存在异常<br>IOException IO 异常<br>SocketException Socket 异常</p></blockquote></li></ul><h3 id="网络-协议"><a href="#网络-协议" class="headerlink" title="网络/协议"></a>网络/协议</h3><ul><li><strong>http 响应码 301 和 302 代表的是什么？有什么区别？</strong><blockquote><p>301：永久重定向；302：暂时重定向。<br>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。</p></blockquote></li></ul><ul><li><strong>forward 和 redirect 的区别？</strong><blockquote><p>forward 是转发 和 redirect 是重定向：<br>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；<br>数据共享：forward 可以共享 request 里的数据，redirect 不能共享；<br>效率：forward 比 redirect 效率高。</p></blockquote></li></ul><ul><li><strong>简述 tcp 和 udp的区别？</strong><blockquote><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。<br>两者的区别大致如下：<br>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；<br>tcp 提供可靠的服务（数据传输），udp 无法保证；<br>tcp 面向字节流，udp 面向报文；<br>tcp 数据传输慢，udp 数据传输快；</p></blockquote></li></ul><ul><li><strong>tcp 为什么要三次握手，两次不行吗？为什么？</strong><blockquote><p>我们假设A和B是通信的双方。我理解的握手实际上就是通信，发一次信息就是进行一次握手。<br>第一次握手： A给B打电话说，你可以听到我说话吗？<br>第二次握手： B收到了A的信息，然后对A说： 我可以听得到你说话啊，你能听得到我说话吗？<br>第三次握手： A收到了B的信息，然后说可以的，我要给你发信息啦！<br>在三次握手之后，A和B都能确定这么一件事： 我说的话，你能听到； 你说的话，我也能听到。 这样，就可以开始正常通信了。<br>注意： HTTP是基于TCP协议的，所以每次都是客户端发送请求，服务器应答，但是TCP还可以给其他应用层提供服务，即可能A、B在建立链接之后，谁都可能先开始通信。<br>如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</p></blockquote></li></ul><ul><li><strong>说一下 tcp 粘包是怎么产生的？</strong><blockquote><p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：<br>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；<br>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</p></blockquote></li></ul><ul><li><strong>OSI 的七层模型都有哪些？</strong><blockquote><p>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。<br>数据链路层：负责建立和管理节点间的链路。<br>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。<br>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。<br>会话层：向两个实体的表示层提供建立和使用连接的方法。<br>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。<br>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</p></blockquote></li></ul><ul><li><strong>get 和 post 请求有哪些区别？</strong><blockquote><p>get 请求会被浏览器主动缓存，而 post 不会。<br>get 传递参数有大小限制，而 post 没有。<br>post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</p></blockquote></li></ul><ul><li><strong>如何实现跨域？</strong><blockquote><p>实现跨域有以下几种方案：<br>服务器端运行跨域 设置 CORS 等于 *；<br>在单个接口使用注解 @CrossOrigin 运行跨域；<br>使用 jsonp 跨域；</p></blockquote></li></ul><ul><li><strong>说一下 JSONP 实现原理？</strong><blockquote><p>jsonp：JSON with Padding，它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。</p></blockquote></li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li><strong>你知道多少种设计模式,可以分为那几类？</strong><blockquote><p>Java中一般认为有23 种设计模式， 总体来说设计模式分为三大类：<br>创建型模式，共五种：<br>工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。<br>结构型模式，共七种：<br>适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。<br>行为型模式，共十一种：<br>策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p></blockquote></li></ul><ul><li><strong>说一下你熟悉的设计模式？</strong><blockquote><p>单例模式：保证被创建一次，节省系统开销。<br>工厂模式（简单工厂、抽象工厂）：解耦代码。<br>观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。<br>外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。<br>模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。<br>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p></blockquote></li></ul><ul><li><strong>简单工厂和抽象工厂有什么区别？</strong><blockquote><p>简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。<br>工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。<br>抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。</p></blockquote></li></ul><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul><li><strong>说一下 JVM 的主要组成部分？及其作用？</strong><blockquote><p>类加载器（ClassLoader）<br>运行时数据区（Runtime Data Area）<br>执行引擎（Execution Engine）<br>本地库接口（Native Interface）<br>组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p></blockquote></li></ul><ul><li><strong>JVM运行时划分哪几个区域？哪些区域是线程共享的？哪些区域是线程独占的？</strong><blockquote><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：<br>JVM运行时一共划分：</p><ol><li>程序计数器(Program Counter Register)：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</li><li>虚拟机栈(Java Virtual Machine Stacks)：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</li><li>堆(Java Heap)：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</li><li>本地方法栈(Native Method Stack)：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</li><li>方法区(Methed Area)：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。<br>线程共享的数据区域：堆、方法区。<br>线程独享的数据区域区域：程序计数器、虚拟机栈、本地方法栈。</li></ol></blockquote></li></ul><ul><li><strong>这几个内存区域分别存放什么数据？</strong><blockquote><p>程序计数器记录当前线程执行的位置；<br>虚拟机栈存储基本数据类型以及对象的引用等；<br>堆存储对象实例；<br>本地方法栈与虚拟机栈类似，它为Native方法服务；<br>方法区存储被JVM加载的类信息、常量、静态变量等。</p></blockquote></li></ul><ul><li><strong>说一下堆栈的区别？</strong><blockquote><p>功能方面：堆是用来存放对象的，栈是用来执行程序的。<br>共享性：堆是线程共享的，栈是线程私有的。<br>空间大小：堆大小远远大于栈。</p></blockquote></li></ul><ul><li><strong>队列和栈是什么？有什么区别？</strong><blockquote><p>队列和栈都是被用来预存储数据的。<br>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。<br>栈和队列很相似，但它运行对元素进行后进先出进行检索。</p></blockquote></li></ul><ul><li><strong>GC回收算法</strong><blockquote><p>(1)标记-清除算法：首先标记出需要回收的对象，标记完成后统一清除。此算法缺点是标记-清楚效率不高，且容易出现大量不连续的碎片空间。<br>(2)复制算法：将内存空间划分成两部分，每次只使用一个内存空间部分，当一个内存空间使用完，将会把存活的对象复制到另一空间，然后一次性清理掉该部分空间。此算法缺点是内存利用率较低，只有一半。<br>(3)标记-整理算法：和标记-清楚算法相同也是先标记出需要回收的对象，但在标记完成后不是直接清除而是将存活的对象像一侧进行移动，再清除边界之外的内存。</p></blockquote></li></ul><ul><li><strong>这三种GC回收算法在JVM中是如何应用的？</strong><blockquote><p>GC主要发生在JVM的堆内存中，堆内存分为”新生代”和”老年代”，新生代的GC称为”Minor GC”，老年代的GC称为”Major GC”。<br>新生代中的GC算法使用复制算法：新生代中分为了Eden区和Survivor区(Survivor from和Survivor to)，新产生的对象实例先在Eden区，Eden区满了过后再在Survivor from区，如果Survivor from区也满了后，将进行Minor GC（复制算法），将存活的对象复制到Survivor to区，此时清除Eden区和Survivor from区，此时Survivor from成为新的Survivor to。新的对象又将在Eden区域进行分配，周而复始。<br>老年代中的GC算法使用标记-清除算法/标记-整理算法，视具体的GC回收器而定。</p></blockquote></li></ul><ul><li><strong>频繁的Full GC会带来什么问题？</strong><blockquote><p>CPU占用率过高，系统出现卡顿。</p></blockquote></li></ul><ul><li><strong>什么是OOM内存溢出，它发生在哪块内存区域？</strong><blockquote><p>OOM通常发生在堆内存上，指的是内存对象没有及时回收，造成没有多余的内存分配给新的对象，此时应该定位程序中是否在频繁创建对象而没有及时回收，或者设置JVM的参数-Xms、-Xmx。<br>但OOM还有一种情况发生在虚拟机栈，此时虚拟机栈并不是因为递归太深造成StackOverflow，而是的的确确发生了OOM。首先，虚拟机栈作为线程独享的内存区域，总的虚拟机栈内存大小有限，也就是可分配的线程大小有限，当每个虚拟机栈设置的内存大小过大时，此时可分配的线程大小就变少，继续创建过多的线程可能会导致无法再分配内存空间，造成虚拟机栈的OOM。此时的解决办法时，适当设置虚拟机栈的内存大小-Xss，以便能创建更多的线程。</p></blockquote></li></ul><ul><li><strong>说一下 JVM 有哪些垃圾回收器？</strong><blockquote><p>Serial：最早的单线程串行垃圾回收器。<br>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。<br>ParNew：是 Serial 的多线程版本。<br>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。<br>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。<br>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。<br>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</p></blockquote></li></ul><ul><li><strong>常用的GC回收器有哪些，有什么特点？</strong><blockquote><p>CMS：通常对老年代的对象进行GC，基于标记-清除算法，是一个低停顿、并发收集的GC回收器。它的GC过程一共分为4个步骤：<br>①初始标记，标记GC Roots能关联的对象（即存活的对象），会停止用户线程。<br>②并发标记，不会停止用户线程，和用户线程一起工作标记可达对象。<br>③重新标记，标记因为在“并发标记”阶段新产生的对象。<br>④并发清除，同用户线程一起工作，清理需要清理的对象。<br>缺点：<br>①占用CPU资源<br>②无法处理并发标记期间产生的浮动垃圾<br>③由于采用标记-清楚算法，会产生大量的内存碎片<br>G1：应用于整个堆上的内存，物理上不再划分年轻代与老年代，只做逻辑保留，采用标记-整理算法，是一个可对停顿时间预测的低停顿、并发收集的GC回收器。它的GC过程同CMS类似，一共分为4个步骤：<br>①初始标记，同CMS回收器一致，标记出存活的对象。<br>②并发标记，同CMS回收器一致，和用户线程并发标记出存活的对象。<br>③最终标记，同CMS回收器一致，修正在并发标记将期间用户线程新产生的对象。<br>④筛选回收，这个阶段可根据用户期望的GC停顿时间制定回收计划。</p></blockquote></li></ul><ul><li><strong>详细介绍一下 CMS 垃圾回收器？</strong><blockquote><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。<br>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p></blockquote></li></ul><ul><li><strong>新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</strong><blockquote><p>新生代回收器：Serial、ParNew、Parallel Scavenge<br>老年代回收器：Serial Old、Parallel Old、CMS<br>整堆回收器：G1<br>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p></blockquote></li></ul><ul><li><strong>简述分代垃圾回收器是怎么工作的？</strong><blockquote><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。<br>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：<br>把 Eden + From Survivor 存活的对象放入 To Survivor 区；<br>清空 Eden 和 From Survivor 分区；<br>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。<br>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。<br>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p></blockquote></li></ul><ul><li><strong>说一下 JVM 调优的工具？</strong><blockquote><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。<br>jconsole：用于对 JVM 中的内存、线程和类等进行监控；<br>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</p></blockquote></li></ul><ul><li><strong>类在JVM中的加载过程</strong><blockquote><p>Java文件被编译为Class字节码文件后被加载到JVM中，<br>主要分为五步：</p><ol><li>加载:根据查找路径找到相应的 class 文件然后导入；</li><li>连接:检查加载的 class 文件的正确性；</li><li>准备:给类中的静态变量分配内存空间；</li><li>解析:虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li><li>初始化:对静态变量和静态代码块执行初始化工作。</li></ol></blockquote></li></ul><ul><li><strong>类是如何被加载到JVM中的？</strong><blockquote><p>Java文件被编译成Class字节码文件后，通过类加载器被加载到JVM中。类加载器从上往下一共有：启动类加载器、扩展类加载器、应用程序类加载器、自定义类加载器。类先从自定义类加载器开始，逐层向上传递到启动类加载器，当启动类加载器不能加载时，再向扩展类加载器加载，这称为双亲委派模型。</p></blockquote></li></ul><ul><li><strong>什么是双亲委派模型？</strong><blockquote><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身统一确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。<br>类加载器分类：<br>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；<br>其他类加载器：<br>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；<br>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。<br>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p></blockquote></li></ul><ul><li><strong>类加载器的双亲委派模型有什么好处？</strong><blockquote><p>假设一个类首先被自定义类加载器加载，我们写Object类时，系统中就会出现不同的Object类。为了保证在系统中始终都只有一个Object类，方法就是它们都通过启动类加载器加载。</p></blockquote></li></ul><ul><li><strong>怎么判断对象是否可以被回收？</strong><blockquote><p>一般有两种方法来判断：<br>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；<br>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</p></blockquote></li></ul><ul><li><strong>Java 中都有哪些引用类型？</strong><blockquote><p>强引用：发生 gc 的时候不会被回收。<br>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。<br>弱引用：有用但不是必须的对象，在下一次GC时会被回收。<br>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 现虚引用，虚引用的用途是在 gc 时返回一个通知。</p></blockquote></li></ul><ul><li><strong>常用的 JVM 调优的参数都有哪些？</strong><blockquote><p>-Xms2g：初始化推大小为 2g；<br>-Xmx2g：堆最大内存为 2g；<br>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；<br>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；<br>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；<br>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；<br>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；<br>-XX:+PrintGC：开启打印 gc 信息；<br>-XX:+PrintGCDetails：打印 gc 详细信息。</p></blockquote></li></ul><h3 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h3><h4 id="Spring-Spring-MVC"><a href="#Spring-Spring-MVC" class="headerlink" title="Spring/Spring MVC"></a>Spring/Spring MVC</h4><ul><li><strong>为什么要使用 spring？</strong><blockquote><p>spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。<br>spring 提供了事务支持，使得事务操作变的更加方便。<br>spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。<br>更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis、hibernate 等。</p></blockquote></li></ul><ul><li><strong>解释一下什么是 aop？</strong><blockquote><p>aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。<br>简单来说就是统一处理某一“切面”（类）的问题的编程思想，比如统一处理日志、异常等。</p></blockquote></li></ul><ul><li><strong>解释一下什么是 ioc？</strong><blockquote><p>ioc：Inversionof Control（中文：控制反转）是 spring 的核心，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。<br>简单来说，控制指的是当前对象对内部成员的控制权；控制反转指的是，这种控制权不由当前对象管理了，由其他（类,第三方容器）来管理。</p></blockquote></li></ul><ul><li><strong>spring 有哪些主要模块？</strong><blockquote><p>spring core：框架的最基础部分，提供 ioc 和依赖注入特性。<br>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。<br>spring dao：Data Access Object 提供了JDBC的抽象层。<br>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。<br>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。<br>spring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现。</p></blockquote></li></ul><ul><li><strong>spring 常用的注入方式有哪些？</strong><blockquote><p>setter 属性注入<br>构造方法注入<br>注解方式注入</p></blockquote></li></ul><ul><li><strong>spring 中的 bean 是线程安全的吗？</strong><blockquote><p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。<br>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。<br>有状态就是有数据存储功能。<br>无状态就是不会保存数据。</p></blockquote></li></ul><ul><li><strong>spring 支持几种 bean 的作用域？</strong><blockquote><p>spring 支持 5 种作用域，如下：<br>singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；<br>prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；<br>request：每次 http 请求都会创建一个 bean；<br>session：同一个 http session 共享一个 bean 实例；<br>global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。<br>注意： 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p></blockquote></li></ul><ul><li><strong>spring 自动装配 bean 有哪些方式？</strong><blockquote><p>no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。<br>byName：它根据 bean 的名称注入对象依赖项。<br>byType：它根据类型注入对象依赖项。<br>构造函数：通过构造函数来注入依赖项，需要设置大量的参数。<br>autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。</p></blockquote></li></ul><ul><li><strong>spring 事务实现方式有哪些？</strong><blockquote><p>声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）。<br>编码方式：提供编码的形式管理和维护事务。</p></blockquote></li></ul><ul><li><strong>说一下 spring 的事务隔离？</strong><blockquote><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：<br>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；<br>ISOLATIONREADUNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；<br>ISOLATIONREADCOMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；<br>ISOLATIONREPEATABLEREAD：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；<br>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。<br>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。<br>不可重复读 ：是指在一个事务内，多次读同一数据。<br>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p></blockquote></li></ul><ul><li><strong>说一下 spring mvc 运行流程？</strong><blockquote><p>spring mvc 先将请求发送给 DispatcherServlet。<br>DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。<br>DispatcherServlet 再把请求提交到对应的 Controller。<br>Controller 进行业务逻辑处理后，会返回一个ModelAndView。<br>Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。<br>视图对象负责渲染返回给客户端。</p></blockquote></li></ul><ul><li><strong>spring mvc 有哪些组件？</strong><blockquote><p>前置控制器 DispatcherServlet。<br>映射控制器 HandlerMapping。<br>处理器 Controller。<br>模型和视图 ModelAndView。<br>视图解析器 ViewResolver。</p></blockquote></li></ul><ul><li><strong>@RequestMapping 的作用是什么？</strong><blockquote><p>将 http 请求映射到相应的类/方法上。</p></blockquote></li></ul><ul><li><strong>@Autowired 的作用是什么？</strong><blockquote><p>@Autowired 它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，通过@Autowired 的使用来消除 set/get 方法。</p></blockquote></li></ul><h4 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h4><ul><li><strong>什么是 spring boot？</strong><blockquote><p>spring boot 是为 spring 服务的，是用来简化新 spring 应用的初始搭建以及开发过程的。</p></blockquote></li></ul><ul><li><strong>为什么要用 spring boot？</strong><blockquote><p>配置简单<br>独立运行<br>自动装配<br>无代码生成和 xml 配置<br>提供应用监控<br>易上手<br>提升开发效率</p></blockquote></li></ul><ul><li><strong>spring boot 核心配置文件是什么？</strong><blockquote><p>spring boot 核心的两个配置文件：<br>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；<br>application (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。</p></blockquote></li></ul><ul><li><strong>spring boot 配置文件有哪几种类型？它们有什么区别？</strong><blockquote><p>配置文件有 . properties 格式和 . yml 格式，它们主要的区别是书法风格不同。<br>properties 配置如下：<br>spring. RabbitMQ. port=5672<br>yml 配置如下：<br>spring:<br>RabbitMQ:<br>port: 5672<br>yml 格式不支持 @PropertySource 注解导入。</p></blockquote></li></ul><ul><li><strong>spring boot 有哪些方式可以实现热部署？</strong><blockquote><p>使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring. devtools. restart. enabled 设置为 true；<br>使用 Intellij Idea 编辑器，勾上自动编译或手动重新编译。</p></blockquote></li></ul><ul><li><strong>jpa 和 hibernate 有什么区别？</strong><blockquote><p>jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。</p></blockquote></li></ul><h4 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h4><ul><li><strong>什么是 spring cloud？</strong><blockquote><p>spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。</p></blockquote></li></ul><ul><li><strong>spring cloud 断路器的作用是什么？</strong><blockquote><p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</p></blockquote></li></ul><ul><li><strong>spring cloud 的核心组件有哪些？</strong><blockquote><p>Eureka：服务注册于发现。<br>Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。<br>Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。<br>Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。<br>Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。</p></blockquote></li></ul><h4 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h4><ul><li><strong>为什么要使用 hibernate？</strong><blockquote><p>hibernate 是对 jdbc 的封装，大大简化了数据访问层的繁琐的重复性代码。<br>hibernate 是一个优秀的 ORM 实现，很多程度上简化了 DAO 层的编码功能。<br>可以很方便的进行数据库的移植工作。<br>提供了缓存机制，是程序执行更改的高效。</p></blockquote></li></ul><ul><li><strong>什么是 ORM 框架？</strong><blockquote><p>ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象。<br>使用 ORM 的优点：提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。</p></blockquote></li></ul><ul><li><strong>hibernate 中如何在控制台查看打印的 SQL 语句？</strong><blockquote><p>在 Config 里面把 hibernate. show_SQL 设置为 true 就可以。但不建议开启，开启之后会降低程序的运行效率。</p></blockquote></li></ul><ul><li><strong>hibernate 有几种查询方式？</strong><blockquote><p>三种：hql、原生 SQL、条件查询 Criteria。</p></blockquote></li></ul><ul><li><strong>hibernate 实体类可以被定义为 final 吗？</strong><blockquote><p>实体类可以定义为 final 类，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 final。</p></blockquote></li></ul><ul><li><strong>在 hibernate 中使用 Integer 和 int 做映射有什么区别？</strong><blockquote><p>Integer 类型为对象，它的值允许为 null，而 int 属于基础数据类型，值不能为 null。</p></blockquote></li></ul><ul><li><strong>hibernate 是如何工作的？</strong><blockquote><p>读取并解析配置文件。<br>读取并解析映射文件，创建 SessionFactory。<br>打开 Session。<br>创建事务。<br>进行持久化操作。<br>提交事务。<br>关闭 Session。<br>关闭 SessionFactory。</p></blockquote></li></ul><ul><li><strong>get()和 load()的区别？</strong><blockquote><p>数据查询时，没有 OID 指定的对象，get() 返回 null；load() 返回一个代理对象。<br>load()支持延迟加载；get() 不支持延迟加载。</p></blockquote></li></ul><ul><li><strong>说一下 hibernate 的缓存机制？</strong><blockquote><p>hibernate 常用的缓存有一级缓存和二级缓存：<br>一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷出缓存；<br>二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。</p></blockquote></li></ul><ul><li><strong>hibernate 对象有哪些状态？</strong><blockquote><p>临时/瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。<br>持久化状态：当调用 Session 的 save/saveOrupdate/get/load/list 等方法的时候，对象就是持久化状态。<br>游离状态：Session 关闭之后对象就是游离状态。</p></blockquote></li></ul><ul><li><strong>在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</strong><blockquote><p>getCurrentSession 会绑定当前线程，而 openSession 则不会。<br>getCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。</p></blockquote></li></ul><ul><li><strong>hibernate 实体类必须要有无参构造函数吗？为什么？</strong><blockquote><p>hibernate 中每个实体类必须提供一个无参构造函数，因为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常。</p></blockquote></li></ul><h4 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h4><ul><li><strong>MyBatis 中 #{}和 ${}的区别是什么？</strong><blockquote><p>#{}是预编译处理，${}是字符替换。 在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。</p></blockquote></li></ul><ul><li><strong>MyBatis 有几种分页方式？</strong><blockquote><p>分页方式：逻辑分页和物理分页。<br>逻辑分页： 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。<br>物理分页： 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。</p></blockquote></li></ul><ul><li><strong>RowBounds 是一次性查询全部结果吗？为什么？</strong><blockquote><p>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。<br>Fetch Size 官方相关文档：<a href="http://t" target="_blank" rel="noopener">http://t</a>. cn/EfSE2g3</p></blockquote></li></ul><ul><li><strong>MyBatis 逻辑分页和物理分页的区别是什么？</strong><blockquote><p>逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。<br>物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。</p></blockquote></li></ul><ul><li><strong>MyBatis 是否支持延迟加载？延迟加载的原理是什么？</strong><blockquote><p>MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。<br>延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。</p></blockquote></li></ul><ul><li><strong>说一下 MyBatis 的一级缓存和二级缓存？</strong><blockquote><p>一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。<br>二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。<br>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。<br>缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p></blockquote></li></ul><ul><li><strong>MyBatis 和 hibernate 的区别有哪些？</strong><blockquote><p>灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。<br>可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差。<br>学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。<br>二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。</p></blockquote></li></ul><ul><li><strong>MyBatis 有哪些执行器（Executor）？</strong><blockquote><p>MyBatis 有三种基本的Executor执行器：<br>SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；<br>ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；<br>BatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。</p></blockquote></li></ul><ul><li><strong>MyBatis 分页插件的实现原理是什么？</strong><blockquote><p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p></blockquote></li></ul><ul><li><strong>MyBatis 如何编写一个自定义插件？</strong><blockquote><p>自定义插件实现原理：<br>MyBatis 自定义插件针对 MyBatis 四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）进行拦截：<br>Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；<br>StatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存；<br>ParameterHandler：拦截参数的处理；<br>ResultSetHandler：拦截结果集的处理。<br>自定义插件实现关键：<br>MyBatis 插件要实现 Interceptor 接口，接口包含的方法，如下：</p></blockquote></li></ul><pre><code>public interface Interceptor {     Object intercept(Invocation invocation) throws Throwable;     Object plugin(Object target);     void setProperties(Properties properties);}</code></pre><blockquote><p>setProperties 方法是在 MyBatis 进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；<br>plugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin. wrap(target, this)；<br>intercept 方法就是要进行拦截的时候要执行的方法。<br>自定义插件实现示例：<br>官方插件实现：</p></blockquote><pre><code>@Intercepts({@Signature(type = Executor. class, method = &quot;query&quot;,args = {MappedStatement. class, Object. class, RowBounds. class, ResultHandler. class})})public class TestInterceptor implements Interceptor {    public Object intercept(Invocation invocation) throws Throwable {        Object target = invocation. getTarget(); //被代理对象        Method method = invocation. getMethod(); //代理方法        Object[] args = invocation. getArgs(); //方法参数        // do something . . . . . . 方法拦截前执行代码块        Object result = invocation. proceed();        // do something . . . . . . . 方法拦截后执行代码块        return result;    }    public Object plugin(Object target) {        return Plugin. wrap(target, this);    } }</code></pre><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><ul><li><strong>RabbitMQ 的使用场景有哪些？</strong><blockquote><p>抢购活动，削峰填谷，防止系统崩塌。<br>延迟信息处理，比如 10 分钟之后给下单未付款的用户发送邮件提醒。<br>解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</p></blockquote></li></ul><ul><li><strong>RabbitMQ 有哪些重要的角色？</strong><blockquote><p>RabbitMQ 中重要的角色有：生产者、消费者和代理：<br>生产者：消息的创建者，负责创建和推送数据到消息服务器；<br>消费者：消息的接收方，用于处理数据和确认消息；<br>代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</p></blockquote></li></ul><ul><li><strong>RabbitMQ 有哪些重要的组件？</strong><blockquote><p>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。<br>Channel（信道）：消息推送使用的通道。<br>Exchange（交换器）：用于接受、分配消息。<br>Queue（队列）：用于存储生产者的消息。<br>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。<br>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</p></blockquote></li></ul><ul><li><strong>RabbitMQ 中 vhost 的作用是什么？</strong><blockquote><p>vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</p></blockquote></li></ul><ul><li><strong>RabbitMQ 的消息是怎么发送的？</strong><blockquote><p>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p></blockquote></li></ul><ul><li><strong>RabbitMQ 怎么保证消息的稳定性？</strong><blockquote><p>提供了事务的功能。<br>通过将 channel 设置为 confirm（确认）模式。</p></blockquote></li></ul><ul><li><strong>RabbitMQ 怎么避免消息丢失？</strong><blockquote><p>把消息持久化磁盘，保证服务器重启消息不丢失。<br>每个集群中至少有一个物理磁盘，保证消息落入磁盘。</p></blockquote></li></ul><ul><li><strong>要保证消息持久化成功的条件有哪些？</strong><blockquote><p>声明队列必须设置持久化 durable 设置为 true.<br>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。<br>消息已经到达持久化交换器。<br>消息已经到达持久化队列。<br>以上四个条件都满足才能保证消息持久化成功。</p></blockquote></li></ul><ul><li><strong>RabbitMQ 持久化有什么缺点？</strong><blockquote><p>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</p></blockquote></li></ul><ul><li><strong>RabbitMQ 有几种广播类型？</strong><blockquote><p>direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。<br>headers：与 direct 类似，只是性能很差，此类型几乎用不到。<br>fanout：分发模式，把消费分发给所有订阅者。<br>topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。</p></blockquote></li></ul><ul><li><strong>RabbitMQ 怎么实现延迟消息队列？</strong><blockquote><p>延迟队列的实现有两种方式：<br>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；<br>使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。</p></blockquote></li></ul><ul><li><strong>RabbitMQ 集群有什么用？</strong><blockquote><p>集群主要有以下两个用途：<br>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；<br>高容量：集群可以承载更多的消息量。</p></blockquote></li></ul><ul><li><strong>RabbitMQ 节点的类型有哪些？</strong><blockquote><p>磁盘节点：消息会存储到磁盘。<br>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</p></blockquote></li></ul><ul><li><strong>148.RabbitMQ 集群搭建需要注意哪些问题？</strong><blockquote><p>各节点之间使用“–link”连接，此属性不能忽略。<br>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。<br>整个集群中必须包含一个磁盘节点。</p></blockquote></li></ul><ul><li><strong>RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</strong><blockquote><p>不是，原因有以下两个：<br>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；<br>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。</p></blockquote></li></ul><ul><li><strong>RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？</strong><blockquote><p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：<br>不能创建队列<br>不能创建交换器<br>不能创建绑定<br>不能添加用户<br>不能更改权限<br>不能添加和删除集群节点<br>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</p></blockquote></li></ul><ul><li><strong>RabbitMQ 对集群节点停止顺序有要求吗？</strong><blockquote><p>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。</p></blockquote></li></ul><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><ul><li><strong>kafka 可以脱离 zookeeper 单独使用吗？为什么？</strong><blockquote><p>kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</p></blockquote></li></ul><ul><li><strong>kafka 有几种数据保留的策略？</strong><blockquote><p>kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</p></blockquote></li></ul><ul><li><strong>kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？</strong><blockquote><p>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</p></blockquote></li></ul><ul><li><strong>什么情况会导致 kafka 运行变慢？</strong><blockquote><p>cpu 性能瓶颈<br>磁盘读写瓶颈<br>网络瓶颈</p></blockquote></li></ul><ul><li><strong>使用 kafka 集群需要注意什么？</strong><blockquote><p>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。<br>集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。</p></blockquote></li></ul><h3 id="Zookeeper-组件"><a href="#Zookeeper-组件" class="headerlink" title="Zookeeper 组件"></a>Zookeeper 组件</h3><ul><li><strong>zookeeper 是什么？</strong><blockquote><p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p></blockquote></li></ul><ul><li><strong>zookeeper 都有哪些功能？</strong><blockquote><p>集群管理：监控节点存活状态、运行请求等。<br>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。<br>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。<br>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</p></blockquote></li></ul><ul><li><strong>zookeeper 有几种部署模式？</strong><blockquote><p>zookeeper 有三种部署模式：<br>单机部署：一台集群上运行；<br>集群部署：多台集群运行；<br>伪集群部署：一台集群启动多个 zookeeper 实例运行。</p></blockquote></li></ul><ul><li><strong>zookeeper 怎么保证主从节点的状态同步？</strong><blockquote><p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p></blockquote></li></ul><ul><li><strong>集群中为什么要有主节点？</strong><blockquote><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p></blockquote></li></ul><ul><li><strong>集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</strong><blockquote><p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p></blockquote></li></ul><ul><li><strong>说一下 zookeeper 的通知机制？</strong><blockquote><p>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p></blockquote></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h4><ul><li><strong>说一下常用的sql优化</strong><blockquote><p>sql优化有很多，一般遵从五个原则：</p><ol><li>减少数据访问： 设置合理的字段类型，启用压缩，通过索引访问等减少磁盘IO</li><li>返回更少的数据： 只返回需要的字段和数据分页处理 减少磁盘io及网络io</li><li>减少交互次数： 批量DML操作，函数存储等减少数据连接次数</li><li>减少服务器CPU开销： 尽量减少数据库排序操作，和全表查询 减少cpu 内存占用</li><li>利用更多资源： 使用表分区，可以增加并行操作，更大限度利用cpu资源：</li></ol><p><strong>sql语句常见的优化比如</strong></p><ol><li>SQL语句全部大写 （所有SQL语句执行时都会转换成大写）</li><li>避免使用星号 * ,用具体字段替代（使用星号会在查询时增加一个查询列的操作）</li><li>尽量避免在 where 子句中对字段进行 null 值判断，最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库,不然会进行全表扫描，影响效率！-反例：select id from t where num is null-可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num = 0</li><li>应尽量避免在 where 子句中使用 != 或 &lt;&gt; ，in 或 not in 操作符 （同上）</li><li>能用between就不要使用in，或者用exists替换in。如：-select num from a where num in(select num from b)用后面的语句替换：select num from a where exists(select 1 from b where num=a.num)</li><li>尽可能的使用 varchar/nvarchar 代替 char/nchar （节省字段存储空间）</li><li>对于复杂的查询，可以使用中间临时表 暂存数据</li><li>查询数据量大的表 会造成查询缓慢。主要的原因是扫描行数过多。这个时候可以通过程序，分段分页进行查询，循环遍历，将结果合并处理进行展示。要查询100000到100050的数据,如:SELECT * FROM (SELECT ROW_NUMBER() OVER(ORDER BY ID ASC) AS rowid,* FROM infoTab)t WHERE t.rowid &gt; 100000 AND t.rowid &lt;= 100050</li><li>对数据量较大的表，使用分区分表存储</li><li>一定要定期维护数据表和优化索引，删除空余数据</li><li>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</li><li>sql优化第一最基本的为了最快的速度查询到数据，减少消耗，尽量避免全表查询，首先考虑在where和order by字段上建立索引</li><li>用like模糊查询时不建议在查询字段开头或首尾两端使用百分号，这也会导致字段放弃索引，全表查询，可以考虑百分号在查询字段后面或者使用全文索引</li><li>在sql中直接使用计算表达式和函数，也会导致索引失败，可以在等号右边计算</li><li>不要写select * from 需要什么字段返回什么字段减少消耗</li></ol><p><strong>Mysql分页优化</strong><br>Mysql在使用limit进行分页查询时有明显的缺陷，比如：SELECT * FROM table ORDER BY id LIMIT x,y;当x越来越大时，因为会查询出x跳记录然后过滤出需要的y条，查询效率会显著降低，为此，有几下集中解决方案：</p><ol><li>先查出上一页结束的数据记录。如:SELECT * FROM table WHERE id&gt;= (SELECT id FROM table LIMIT 1000000, 1) LIMIT 10`</li><li>如果id是连续的，建议使用between。如:SELECT * FROM table WHERE id BETWEEN 1000000 AND 1000010;</li><li>还有一种，可以在查询下一页时把上一页的行id作为参数传递给客户端程序，然后sql就改成了select * from table where id&gt;3000000 limit 10;</li></ol></blockquote></li></ul><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><ul><li><strong>数据库的三范式是什么？</strong><blockquote><p>第一范式（1NF）：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。<br>第二范式（2NF）：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。（在1NF基础上消除非主属性对主键的部分函数依赖）<br>第三范式（3NF）：任何非主属性不依赖于其它非主属性。（在2NF基础上消除传递依赖）</p></blockquote></li></ul><ul><li><strong>一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？</strong><blockquote><p>表类型如果是 MyISAM ，那 id 就是 8。<br>表类型如果是 InnoDB，那 id 就是 6。<br>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p></blockquote></li></ul><ul><li><strong>如何获取当前数据库版本？</strong><blockquote><p>使用 select version() 获取当前 MySQL 数据库版本。</p></blockquote></li></ul><ul><li><strong>说一下 ACID 是什么？</strong><blockquote><p>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。<br>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。<br>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。<br>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></blockquote></li></ul><ul><li><strong>char 和 varchar 的区别是什么？</strong><blockquote><p>char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。<br>优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。<br>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。<br>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p></blockquote></li></ul><ul><li><strong>float 和 double 的区别是什么？</strong><blockquote><p>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。<br>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</p></blockquote></li></ul><ul><li><strong>MySQL 的内连接、左连接、右连接有什么区别？</strong><blockquote><p>内连接关键字：inner join；左连接：left join；右连接：right join。<br>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p></blockquote></li></ul><ul><li><strong>MySQL 索引是怎么实现的？</strong><blockquote><p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。<br>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p></blockquote></li></ul><ul><li><strong>怎么验证 MySQL 的索引是否满足需求？</strong><blockquote><p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。<br>explain 语法：explain select * from table where type=1。</p></blockquote></li></ul><ul><li><strong>说一下数据库的事务隔离？</strong><blockquote><p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：<br>transaction-isolation = REPEATABLE-READ<br>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。<br>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。<br>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。<br>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。<br>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。<br>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。<br>不可重复读 ：是指在一个事务内，多次读同一数据。<br>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p></blockquote></li></ul><ul><li><strong>说一下 MySQL 常用的引擎？</strong><blockquote><p>InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(<em>) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。<br>MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(</em>) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p></blockquote></li></ul><ul><li><strong>说一下 MySQL 的行锁和表锁？</strong><blockquote><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。<br>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。<br>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</p></blockquote></li></ul><ul><li><strong>说一下乐观锁和悲观锁？</strong><blockquote><p>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。<br>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。<br>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p></blockquote></li></ul><ul><li><strong>MySQL 问题排查都有哪些手段？</strong><blockquote><p>使用 show processlist 命令查看当前所有连接信息。<br>使用 explain 命令查询 SQL 语句执行计划。<br>开启慢查询日志，查看慢查询的 SQL。</p></blockquote></li></ul><ul><li><strong>如何做 MySQL 的性能优化？</strong><blockquote><p>为搜索字段创建索引。<br>避免使用 select *，列出需要查询的字段。<br>垂直分割分表。<br>选择正确的存储引擎。</p></blockquote></li></ul><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><ul><li><strong>Redis 是什么？都有哪些使用场景？</strong><blockquote><p>Redis 是一个使用 C 语言开发的高速缓存数据库。<br>redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave主从同步【主从同步：数据可以从主服务器向任意数量的从服务器上同步】。<br>Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。<br>Redis 使用场景：<br>记录帖子点赞数、点击数、评论数；<br>缓存近期热帖；<br>缓存文章详情信息；<br>记录用户会话信息。</p></blockquote></li></ul><ul><li><strong>Redis 有哪些功能？</strong><blockquote><p>数据缓存功能<br>分布式锁的功能<br>支持数据持久化<br>支持事务<br>支持消息队列</p></blockquote></li></ul><ul><li><strong>Redis 和 memcache 有什么区别？</strong><blockquote><p>存储方式不同：memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部份存在硬盘上，这样能保证数据的持久性。<br>数据支持类型：memcache 对数据类型支持相对简单；Redis 有复杂的数据类型。<br>使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，Redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。<br>value 值大小不同：Redis 最大可以达到 1gb；memcache 只有 1mb。</p></blockquote></li></ul><ul><li><strong>Redis 为什么是单线程的？</strong><blockquote><p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。<br>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。而且单线程并不代表就慢， nginx 和 node.js 也都是高性能单线程的代表。</p></blockquote></li></ul><ul><li><strong>什么是缓存穿透？怎么解决？</strong><blockquote><p>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。<br>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p></blockquote></li></ul><ul><li><strong>Redis 支持的数据类型有哪些？</strong><blockquote><p>Redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。</p></blockquote></li></ul><ul><li><strong>Redis 支持的 Java 客户端都有哪些？</strong><blockquote><p>支持的 Java 客户端有 Redisson、jedis、lettuce 等。</p></blockquote></li></ul><ul><li><strong>jedis 和 Redisson 有哪些区别？</strong><blockquote><p>jedis：提供了比较全面的 Redis 命令的支持。<br>Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。</p></blockquote></li></ul><ul><li><strong>怎么保证缓存和数据库数据的一致性？</strong><blockquote><p>合理设置缓存的过期时间。<br>新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</p></blockquote></li></ul><ul><li><strong>Redis 持久化有几种方式？</strong><blockquote><p>Redis 的持久化有两种方式，或者说有两种策略：<br>RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。<br>AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。</p></blockquote></li></ul><ul><li><strong>Redis 怎么实现分布式锁？</strong><blockquote><p>Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。<br>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p></blockquote></li></ul><ul><li><strong>Redis 分布式锁有什么缺陷？</strong><blockquote><p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p></blockquote></li></ul><ul><li><strong>Redis 如何做内存优化？</strong><blockquote><p>尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。</p></blockquote></li></ul><ul><li><strong>Redis 淘汰策略有哪些？</strong><blockquote><p>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。<br>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。<br>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。<br>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。<br>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。<br>no-enviction（驱逐）：禁止驱逐数据。</p></blockquote></li></ul><ul><li><strong>Redis 常见的性能问题有哪些？该如何解决？</strong><blockquote><p>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。<br>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</p></blockquote></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这个技术更新迭代飞快,人才辈出的时代,技术固然重要,但良好的沟通能力,潜力,心态也同样是不可忽视的重要因素。加油吧！骚年~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2019/08/07/java面试必备题库/javaLogo.jpg&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;
&lt;p&gt;你还在为找不到工作烦恼？你还在为拿不到offer而夜不能寐？你还在为面试东奔西走而久久不得到认可？你还在为达不到你想要的薪资而纠结要不要去上班？何不停下脚步，看看下面的知识点你都会了？&lt;/p&gt;
&lt;p&gt;最后愿程序猿梦里没有秃头，也没有改不完的BUG，阿里路亚~&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="/tags/java/"/>
    
      <category term="面试题" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>hexo解决图片显示不了</title>
    <link href="/2019/08/07/hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E4%B8%8D%E4%BA%86/"/>
    <id>/2019/08/07/hexo解决图片显示不了/</id>
    <published>2019-08-07T03:21:23.000Z</published>
    <updated>2019-08-13T03:21:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在弄博客是时候不能幸免的遇到过图片显示的问题。当时网上看了很多解决方案，貌似都不顶用，也不知道是咋回事，郁闷得想吃包子的心都有。<a id="more"></a></p><h3 id="错误描述"><a href="#错误描述" class="headerlink" title="错误描述"></a>错误描述</h3><p>hexo博客显示图片失败，编译出来路径错误，无法加载图片！</p><p><img src="/2019/08/07/hexo解决图片显示不了/%E6%97%A0%E5%8F%91%E6%98%BE%E7%A4%BA.jpg" alt="无发显示"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>输入：<strong>npm install https://github.com/CodeFalling/hexo-asset-image –save</strong> 或者 <strong>npm install hexo-asset-image –save</strong>  推荐前者</li><li>打开博客根目录的<strong>_config.yml</strong> 找到 <strong>post_asset_folder</strong> 属性 设置为<strong>true</strong></li><li>博客根目录的<strong>_config.yml</strong> 找到 <strong>url</strong>属性 设置为<strong>/</strong></li><li>输入: <strong>hexo new “博文名称”</strong> 新建博文 图片放在博文同名的文件夹中</li><li>引用图片就直接 <strong>![说明](图片名称.jpg)</strong>引入。</li><li>输入：<strong>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</strong> 就ok了</li></ol><h3 id="心路历程"><a href="#心路历程" class="headerlink" title="心路历程"></a>心路历程</h3><p>刚搭建的时候也不知道会有图片显示的问题，那时候直接将图片放在主题的img文件夹中，直接可以引用，像引用头像一样。但是很不巧，弄主题的时候，发现别人都不是这么玩的。尴尬！<br>一. 人家都是在博客根目录输入：<strong>npm install hexo-asset-image –save</strong>  安装图片插件</p><p>二. 然后打开博客根目录的<strong>_config.yml</strong> 找到 <strong>post_asset_folder</strong> 属性 设置为<strong>true</strong> 默认为<strong>false</strong></p><p><img src="/2019/08/07/hexo解决图片显示不了/%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE.jpg" alt="图片配置"></p><p><strong>post_asset_folder</strong>属性作用：为每次创建博文文件的时候会创建一个同名称的文件夹，用来放博文相关文件。目录为：<strong>hexo\source_posts</strong> 如下：</p><p><img src="/2019/08/07/hexo解决图片显示不了/%E5%B1%9E%E6%80%A7%E6%A1%88%E4%BE%8B.jpg" alt="属性案例"></p><p>三. 然后再编辑完博文之后 输入: <strong>hexo g &amp;&amp; hexo s</strong> 生成静态文件 并 运行服务<br>访问服务地址，发现还是不能显示。</p><p><img src="/2019/08/07/hexo解决图片显示不了/%E6%97%A0%E5%8F%91%E6%98%BE%E7%A4%BA.jpg" alt="无发显示"></p><p>查看了一下源码发现路径不对，我编写的时候路径给的是<strong>\ ![test](test.jpg)</strong>,但是编译之后路径前面多了一个<strong>.com/</strong> 咋回事，玩我是吧！</p><p><img src="/2019/08/07/hexo解决图片显示不了/%E8%B7%AF%E5%BE%84%E9%94%99%E8%AF%AF.jpg" alt="路径错误"></p><p>然后各种问度娘，各种资料看又收获一图片插件，说起来很厉害的样子<br>输入：<strong>npm install https://github.com/CodeFalling/hexo-asset-image –save</strong><br>发现依然不能显示，我勒个去呀，爆炸有木有。又没心情弄了好吧！查看了一下源码发现路径还是不对，比上面的多了个日期，但是路径前面还是有<strong>.com/</strong> ，我是不能忍，咋程序员就要有勇于探索的神经不是！跑去插件目录（<strong>node_modules文件夹下</strong>）找到 <strong>hexo-asset-image</strong> 目录打开<strong>index.js</strong></p><p><img src="/2019/08/07/hexo解决图片显示不了/%E6%89%93%E5%BC%80js%E6%96%87%E4%BB%B6.jpg" alt="打开js文件"></p><p>再最下面找到<strong>$(this).attr(‘src’, config.root + link + src);</strong>这一剧代码修改为<strong>$(this).attr(‘src’, src);</strong></p><p><img src="/2019/08/07/hexo解决图片显示不了/%E4%BF%AE%E6%94%B9js.jpg" alt="修改js"></p><p>保存 输入：<strong>hexo g &amp;&amp; hexo s</strong> 搞定了！</p><p><img src="/2019/08/07/hexo解决图片显示不了/%E6%90%9E%E5%AE%9A.jpg" alt="搞定"></p><p>后来有次在主页显示图片发现图片没有显示出来，仔细一想也对 ，上面的做法修改js的路径拼接，直接将图片的路径写死成了 相对路径，就是说只有文件和图片处在同一层级才能显示，然后撸了一下插件的js发现npm install hexo-asset-image –save生成的路径是从博客文章开始的，而npm install https://github.com/CodeFalling/hexo-asset-image –save插件的话生成出来的路径是从public目录下开始的。而那多出来的//yoursite.com路径则的博客根目录——config.yml下的url的配置，将它设置为“/”就可以了。</p><p><img src="/2019/08/07/hexo解决图片显示不了/%E4%B8%BB%E9%A1%B5%E6%98%BE%E7%A4%BA.jpg" alt="主页显示"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>每次修改配置需要重新清理 hexo clean 然后重新编译 hexo g 不然配置没有生效。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>开发的时候，有时候真的是很考验心态，常常一点点小问题，折磨的你欲仙欲死。而且特别花时间，所以遇到问题还是要冷静思考一下，实在不行就放一放，后续在弄，不然很难抽身出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在弄博客是时候不能幸免的遇到过图片显示的问题。当时网上看了很多解决方案，貌似都不顶用，也不知道是咋回事，郁闷得想吃包子的心都有。&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="/tags/hexo/"/>
    
      <category term="图片显示" scheme="/tags/%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA/"/>
    
  </entry>
  
  <entry>
    <title>windows远程连接&#39;登录没有成功&#39;,&#39;你的凭据不工作&#39;</title>
    <link href="/2019/08/07/windows%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5-%E7%99%BB%E5%BD%95%E6%B2%A1%E6%9C%89%E6%88%90%E5%8A%9F-%E4%BD%A0%E7%9A%84%E5%87%AD%E6%8D%AE%E4%B8%8D%E5%B7%A5%E4%BD%9C/"/>
    <id>/2019/08/07/windows远程连接-登录没有成功-你的凭据不工作/</id>
    <published>2019-08-06T20:16:41.000Z</published>
    <updated>2019-08-09T09:10:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>买了一台windows的云服务，装的2008的系统（老归老，吃内存少）结果远程连接不上，也是很服气了，别人都可以连接，而且最气的是都是win10系统，这不是在针对我么？我勒个不爽呀！一百万个羊驼有木有。<a id="more"></a></p><h3 id="错误描述"><a href="#错误描述" class="headerlink" title="错误描述"></a>错误描述</h3><p>打开远程连接工具之后，填写计算机和用户名</p><p><img src="/2019/08/07/windows远程连接-登录没有成功-你的凭据不工作/%E9%94%99%E8%AF%AF%E6%8F%8F%E8%BF%B01.jpg" alt="错误描述1"></p><p>点击确认出现下面错误，’登录没有成功’,’你的凭据不工作’</p><p> <img src="/2019/08/07/windows远程连接-登录没有成功-你的凭据不工作/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5.jpg" alt="错误描述2"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>鼓捣了半天，还是把他给拿下了，解决方案很简单。将2个用户名同步即可 比如 都为：MicrosoftAccount\Administrator （输入该用户名之后，点击连接，你的凭据也会变为该用户名）</p><p> <img src="/2019/08/07/windows远程连接-登录没有成功-你的凭据不工作/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881.jpg" alt="解决方案1"></p><p>或者都为：Administrator</p><p> <img src="/2019/08/07/windows远程连接-登录没有成功-你的凭据不工作/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882.jpg" alt="解决方案2"></p><h3 id="原因-用户所在域问题"><a href="#原因-用户所在域问题" class="headerlink" title="原因-用户所在域问题"></a>原因-用户所在域问题</h3><p>Win8以后的Microsoft账户问题，由于Win8以后开始使用MS账户，由此产生了一些“无法远程”的问题。究其原因，是MS账户的域的问题。如上图所示，这是一台已登录MS账户的Win10计算机，想远程某个Win7机器时，域被自动设置成了MicrosoftAccount，此时输入用户名密码后，会提示凭据无法工作。这是因为远程计算机本地账户的域不是MicrosoftAccount，因此需要显式指定计算机的域。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>远程连接失败有很多种可能性，但这一种比较常见。草鸡简单呀有木有！真是，牙疼不是病，疼起来要你命啊！一点点小问题，不知道的话可以折磨得你欲仙欲死有木有。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;买了一台windows的云服务，装的2008的系统（老归老，吃内存少）结果远程连接不上，也是很服气了，别人都可以连接，而且最气的是都是win10系统，这不是在针对我么？我勒个不爽呀！一百万个羊驼有木有。&lt;/p&gt;
    
    </summary>
    
    
      <category term="windows" scheme="/tags/windows/"/>
    
      <category term="远程连接" scheme="/tags/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>JDK从1.0到12各版本介绍</title>
    <link href="/2019/08/02/JDK%E4%BB%8E1-0%E5%88%B012%E5%90%84%E7%89%88%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <id>/2019/08/02/JDK从1-0到12各版本介绍/</id>
    <published>2019-08-02T02:32:30.000Z</published>
    <updated>2019-08-02T10:04:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>收集了一些JDK各个版本的重要特性，作为一个java开发，除了常用版本与当前火热的版本要了如指掌以外，其他版本也多少都得了解一些吧，不然还不得被小伙伴们笑掉大门牙呀！<a id="more"></a></p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>为了保护小伙伴们的大门牙，下面开始进入正题！</p><h5 id="JDK-1-0-开发代号为-Oak-橡树"><a href="#JDK-1-0-开发代号为-Oak-橡树" class="headerlink" title="JDK 1.0 开发代号为 Oak(橡树)"></a>JDK 1.0 开发代号为 Oak(橡树)</h5><blockquote><p><strong>简介:</strong><br>1995年初发布了Java语言,1996年1月23日，jdk1.0版本发布。jdk1.0当时还是一个纯解释执行的Java虚拟机，性能比较差，运行速度慢。<br>此版本包括两个部分:运行环境（即Java Runtime Environment,JRE）和开发环境（Java Development Kit,IDK）。运行环境包括核心API，集成API、用户界面API、发布技术、Java虚拟机（Java Virtual Machine，JVM）五个部分；其中开发环境包括编译Java程序的编译器（javac 命令）。</p></blockquote><blockquote><p><strong>jdk1.0版本的代表技术:</strong></p><ul><li>Java虚拟机</li><li>Applet</li><li>AWT</li><li>等（我是形容词）</li></ul></blockquote><h5 id="JDK-1-1-开发代号为-Coffce-咖啡"><a href="#JDK-1-1-开发代号为-Coffce-咖啡" class="headerlink" title="JDK 1.1 开发代号为 Coffce(咖啡)"></a>JDK 1.1 开发代号为 Coffce(咖啡)</h5><blockquote><p><strong>简介:</strong><br>1997年2月19日，jdk1.1版本发布。增加了JIT（Just In Time,即时编译）编译器。相对于传统编译器，它会将经常用到的指令保存到内存中。当下次调用的时候不需要重新编译了，此方式让JDK在效率上有了较大优势。</p></blockquote><blockquote><p><strong>jdk1.1的代表技术:</strong> <br><br>JAR文件格式:</p><ul><li>JDBC(Java Database Connectivity）</li><li>JavaBean</li><li>RMI（Remote Method Invocation）<br>语言上:</li><li>内部类（inner Class）</li><li>反射（introspect reflex）</li></ul></blockquote><h5 id="JDK-1-2-开发代号为-Playground-运动场"><a href="#JDK-1-2-开发代号为-Playground-运动场" class="headerlink" title="JDK 1.2 开发代号为 Playground(运动场)"></a>JDK 1.2 开发代号为 Playground(运动场)</h5><blockquote><p><strong>简介:</strong><br>1998年12月4日jdk迎来了一个里程碑的版本1.2。技术体系<br>被分为三个方向，J2SE，J2EE，J2ME。代表技术：EJB，Java Plug-in ，Swing。该版本中虚拟机第一次内置了JIT编译器。语言上：Collections集合类等。<br>1994年4月27日，HotSpot虚拟机发布，该虚拟机是作为jdk2.0的附加程序提供的，后来成为jdk1.3及以后所有版本的Sun jdk 的默认虚拟机。</p></blockquote><blockquote><p><strong>jdk1.2版本的代表技术：</strong></p><ul><li>集合框架</li><li>字符串常量做内存映射</li><li>JIT编译器 (Just In Time)</li><li>对打包Java文件数字签名</li><li>控制授权访问系统资源的策略工具</li><li>JFC(Java Foundation Classes)  Swing 1.0</li><li>拖放和Java2D类库</li><li>Java插件</li><li>JDBC可滚动结果集</li><li>BLOB</li><li>CLOB</li><li>批量更新和用户自定义类型</li><li>Applet中添加声音支持</li></ul></blockquote><h5 id="JDK-1-3-开发代号为-Kestrel-美洲红隼"><a href="#JDK-1-3-开发代号为-Kestrel-美洲红隼" class="headerlink" title="JDK 1.3 开发代号为 Kestrel(美洲红隼)"></a>JDK 1.3 开发代号为 Kestrel(美洲红隼)</h5><blockquote><p><strong>简介：</strong><br>2000年5月8日，jdk1.3发布。jdk1.3对于jdk1.2的改进重要在于一些类库，JNDI服务从jdk1.3开始被作为一项平台级服务提供。</p></blockquote><blockquote><p><strong>jdk1.3版本的代表技术：</strong> </p><ul><li>Java Sound API</li><li>jar文件索引</li><li>对Java的各个方面都做了大量优化和增强</li></ul></blockquote><h5 id="JDK-1-4-开发代号-Merlin-灰背隼"><a href="#JDK-1-4-开发代号-Merlin-灰背隼" class="headerlink" title="JDK 1.4 开发代号 Merlin(灰背隼)"></a>JDK 1.4 开发代号 Merlin(灰背隼)</h5><blockquote><p><strong>简介：</strong><br>2002年2月13日，jdk1.4发布。该版本是Java走向成熟的一个版本，许多著名的公司都有参与甚至实现自己独立的jdk1.4，基于Java语言的开源框架：都能直接运行在jdk1.4至上。Struts、WebWork、Hibernate、Spring等；大量企业应用服务器也开始涌现：WebLogic、WebSphere、JBoss等。</p></blockquote><blockquote><p><strong>jdk1.4版本的代表技术：</strong> </p><ul><li>正则表达式（Regular）</li><li>异常链（链式异常处理）</li><li>NIO</li><li>日志类（Logging）</li><li>XML解析器</li><li>Java打印服务</li><li>Java Web Start</li><li>JDBC 3.0 API</li><li>断言机制</li><li>参数API (Preferences)</li><li>image I/O API</li></ul></blockquote><h5 id="JDK-1-5-开发代号-Tiger-老虎"><a href="#JDK-1-5-开发代号-Tiger-老虎" class="headerlink" title="JDK 1.5 开发代号 Tiger(老虎)"></a>JDK 1.5 开发代号 Tiger(老虎)</h5><blockquote><p><strong>简介：</strong><br>2004年9月30日，jdk1.5发布。Sun将JDK1.5改为Java5.0，J2EE、J2SE和J2ME也相应的改为Java SE、Java ME、Java EE。发布新的企业级平台规范，如通过注释等新特性来简化EJB的复杂性，并推出EJB3.0规范，还推出了自己的MVC框架规范：JSF。该版本在Java语法的易用性做了非常大的改进。</p></blockquote><blockquote><p><strong>主要变更内容：</strong> </p><ul><li>自动装箱与拆箱</li><li>枚举 (Enum)</li><li>静态导入（ import static）</li><li>可变参数（Varargs）</li><li>内省（Introspector）</li><li>泛型(Generic) </li><li>For-Each循环</li><li>元数据注解(Annotation) </li></ul></blockquote><h5 id="JDK-1-6-开发代号-Mustang-野马"><a href="#JDK-1-6-开发代号-Mustang-野马" class="headerlink" title="JDK 1.6 开发代号 Mustang(野马)"></a>JDK 1.6 开发代号 Mustang(野马)</h5><blockquote><p><strong>简介：</strong><br>2006年4月，jdk1.6发布，引入了一个支持脚本引擎的新框架、UI的增强、对WebService支持的增强（JAX-WS2.0和JAXB2.0）、一系列新的安全相关的增强、JDBC4.0、Compiler API、通用的Annotations支持。</p></blockquote><blockquote><p><strong>主要变更内容：</strong> </p><ul><li>Desktop类和SystemTray类 </li><li>使用JAXB2来实现对象与XML之间的映射 </li><li>理解StAX</li><li>使用Compiler API</li><li>轻量级Http Server API</li><li>插入式注解处理API(Pluggable Annotation Processing API) </li><li>用Console开发控制台程序</li><li>对脚本语言的支持如: ruby, groovy, javascript，Common Annotations</li></ul></blockquote><h5 id="JDK-1-7-开发代号-Dolphin-海豚"><a href="#JDK-1-7-开发代号-Dolphin-海豚" class="headerlink" title="JDK 1.7 开发代号 Dolphin(海豚)"></a>JDK 1.7 开发代号 Dolphin(海豚)</h5><blockquote><p><strong>简介：</strong><br>2011年7月28日，jdk1.7发布，引入了二进制整数、支持字符串的switch语句、菱形语法、多异常捕捉、自动关闭资源的try语句等新特性。</p></blockquote><blockquote><p><strong>主要变化内容：</strong> </p><ul><li>switch中可以使用字串</li><li>“&lt;&gt;”这个玩意儿的运用List<string> tempList = new ArrayList&lt;&gt;(); 即泛型实例化类型自动推断。</string></li><li>自定义自动关闭类</li><li>新增一些取环境信息的工具方法</li><li>Boolean类型反转，空指针安全，参与位运算</li><li>两个char间的equals</li><li>安全的加减乘除</li><li>对Java集合（Collections）的增强支持</li><li>数值可加下划线</li><li>支持二进制文字</li><li>简化了可变参数方法的调用</li><li>在try catch异常扑捉中，一个catch可以写多个异常类型，用”|”隔开</li><li>jdk7之前，你必须用try{}finally{}在try内使用资源，在finally中关闭资源，不管try中的代码是否正常退出或者异常退出。jdk7之后，你可以不必要写finally语句来关闭资源，只要你在try()的括号内部定义要使用的资源。</li></ul></blockquote><h5 id="JDK-1-8-开发代号-Spider-蜘蛛"><a href="#JDK-1-8-开发代号-Spider-蜘蛛" class="headerlink" title="JDK 1.8 开发代号 Spider(蜘蛛)"></a>JDK 1.8 开发代号 Spider(蜘蛛)</h5><blockquote><p><strong>简介：</strong><br>2014年03月18日,oracle公司发布了Java1.8，Java1.8是Java语言开发的一个主要版本，带来了全新的Lambda表达式，函数式接口、Lambda 表达式、集合的流式操作、注解的更新、安全性的增强、IO\NIO 的改进、完善的全球化功能等。</p></blockquote><blockquote><p><strong>主要变化内容：</strong> </p><ul><li>接口的默认方法  - 默认方法就是一个在接口里面有了一个实现的方法。</li><li>Lambda 表达式  - Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。</li><li>函数式接口 </li><li>方法与构造函数引用  - 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使用语言的构造更紧凑简洁，减少冗余代码。</li><li>Lambda 作用域</li><li>访问局部变量</li><li>访问对象字段与静态变量</li><li>访问接口的默认方法</li><li>Date API</li><li>支持多重注解</li><li>管道和流</li><li>新工具 - 新的编译工具，如：Nashorn引擎jjs，类依赖分析器jdeps</li><li>可选类 - 可选类已经成为Java 8类库的一部分，用来解决空指针异常</li><li>Nashorn，JavaScript引擎 - Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用<br>JDK 1.8 为当前使用最多的版本，（听说马上1.8以上的版本就要收费了！）点击<a href="https://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" target="_blank" rel="noopener">1.8发行说明</a>更详细。</li></ul></blockquote><h5 id="JDK-1-9-开发代号-Elephant-巨象"><a href="#JDK-1-9-开发代号-Elephant-巨象" class="headerlink" title="JDK 1.9 开发代号 Elephant(巨象)"></a>JDK 1.9 开发代号 Elephant(巨象)</h5><blockquote><p><strong>简介：</strong><br>2017 年 9 月 22 日，oracle公司发布了Java1.9，带来了很多新特性，其中最主要的变化是已经实现的模块化系统。接下来我们会详细介绍 Java 9 的新特性。</p></blockquote><blockquote><p><strong>jdk1.9主要变化内容有：</strong> </p><ul><li>模块系统：模块是一个包的容器，Java 9 最大的变化之一是引入了模块系统（Jigsaw 项目）。</li><li>REPL (JShell)：交互式编程环境。</li><li>HTTP 2 客户端：HTTP/2标准是HTTP协议的最新版本，新的 HTTPClient API 支持 WebSocket 和 HTTP2 流以及服务器推送特性。</li><li>改进的 Javadoc：Javadoc 现在支持在 API 文档中的进行搜索。另外，Javadoc 的输出现在符合兼容 HTML5 标准。</li><li>多版本兼容 JAR 包：多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本。</li><li>集合工厂方法：List，Set 和 Map 接口中，新的静态工厂方法可以创建这些集合的不可变实例。</li><li>私有接口方法：在接口中使用private私有方法。我们可以使用 private 访问修饰符在接口中编写私有方法。</li><li>进程 API: 改进的 API 来控制和管理操作系统进程。引进 java.lang.ProcessHandle 及其嵌套接口 Info 来让开发者逃离时常因为要获取一个本地进程的 PID 而不得不使用本地代码的窘境。</li><li>改进的 Stream API：改进的 Stream API 添加了一些便利的方法，使流处理更容易，并使用收集器编写复杂的查询。</li><li>改进 try-with-resources：如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中使用该变量，而无需在 try-with-resources 语句中声明一个新变量。</li><li>改进的弃用注解 @Deprecated：注解 @Deprecated 可以标记 Java API 状态，可以表示被标记的 API 将会被移除，或者已经破坏。</li><li>改进钻石操作符(Diamond Operator) ：匿名类可以使用钻石操作符(Diamond Operator)。</li><li>改进 Optional 类：java.util.Optional 添加了很多新的有用方法，Optional 可以直接转为 stream。</li><li>多分辨率图像 API：定义多分辨率图像API，开发者可以很容易的操作和展示不同分辨率的图像了。</li><li>改进的 CompletableFuture API ： CompletableFuture 类的异步机制可以在 ProcessHandle.onExit 方法退出时执行操作。</li><li>轻量级的 JSON API：内置了一个轻量级的JSON API</li><li>响应式流（Reactive Streams) API: Java 9中引入了新的响应式流 API 来支持 Java 9 中的响应式编程。</li></ul></blockquote><h5 id="JDK-2-0-开发代号是forest-森林"><a href="#JDK-2-0-开发代号是forest-森林" class="headerlink" title="JDK 2.0 开发代号是forest(森林)"></a>JDK 2.0 开发代号是forest(森林)</h5><blockquote><p><strong>简介：</strong><br>jdk2.0正式版将在2018年3月份发布。</p></blockquote><blockquote><p><strong>jdk2.0变化内容：</strong> </p><ul><li>局部变量类型推断:局部变量类型推断将引入”var”关键字，也就是你可以随意定义变量而不必指定变量的类型.</li><li>GC改进和内存管理</li><li>线程本地握手（JEP 312）</li><li>备用内存设备上的堆分配（JEP 316）</li><li>其他Unicode语言 - 标记扩展（JEP 314）</li><li>基于Java的实验性JIT编译器</li><li>根证书（JEP 319）</li><li>将JDK生态整合单个存储库（JEP 296）</li><li>删除工具javah（JEP 313）</li></ul></blockquote><h5 id="JDK-2-1"><a href="#JDK-2-1" class="headerlink" title="JDK 2.1"></a>JDK 2.1</h5><blockquote><p><strong>简介：</strong><br>jdk1.11 正式版将在2018年9月份发布。</p></blockquote><blockquote><p><strong>jdk1.11变化内容：</strong> </p><ul><li>Nest-Based访问控制</li><li>动态类文件常量</li><li>改善Aarch64 intrinsic</li><li>无操作垃圾收集器</li><li>消除Java EE和CORBA模块</li><li>HTTP客户端(标准)</li><li>局部变量的语法λ参数</li><li>Curve25519和Curve448关键协议</li><li>Unicode 10</li><li>飞行记录器</li><li>ChaCha20和Poly1305加密算法</li><li>发射一列纵队源代码程序</li><li>低开销堆分析</li><li>传输层安全性(Transport Layer Security,TLS)1.3</li><li>动作:一个可伸缩的低延迟垃圾收集器 (实验)</li><li>反对Nashorn JavaScript引擎</li><li>反对Pack200工具和API</li></ul></blockquote><h5 id="JDK-2-2"><a href="#JDK-2-2" class="headerlink" title="JDK 2.2"></a>JDK 2.2</h5><blockquote><p><strong>简介：</strong><br>jdk1.12 正式版将在2019年3月份发布。</p></blockquote><blockquote><p><strong>jdk1.12变化内容：</strong> </p><ul><li>低暂停时间的 GC </li><li>微基准测试套件 </li><li>Switch 表达式 </li><li>JVM 常量 API </li><li>只保留一个 AArch64 实现 </li><li>默认类数据共享归档文件 </li><li>可中止的 G1 Mixed GC </li><li>G1 及时返回未使用的已分配内存</li></ul></blockquote><h3 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h3><p>JAVA 到现在也差不多23年了，还记得以前玩诺基亚上的小游戏，启动就是一个大大的热咖啡图片（Java logo）以及同样大大的java字样，真是感触良多呀！小伙伴们是不是要趁着java还热门，赶紧多学一点呢。毕竟过了这个村，下个村就没有花菇凉了哦！！😄</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;收集了一些JDK各个版本的重要特性，作为一个java开发，除了常用版本与当前火热的版本要了如指掌以外，其他版本也多少都得了解一些吧，不然还不得被小伙伴们笑掉大门牙呀！&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="/tags/java/"/>
    
      <category term="jdk版本" scheme="/tags/jdk%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>java计算坐标绕另一个坐标任意角度旋转</title>
    <link href="/2019/08/02/java%E8%AE%A1%E7%AE%97%E5%9D%90%E6%A0%87%E7%BB%95%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%9D%90%E6%A0%87%E4%BB%BB%E6%84%8F%E8%A7%92%E5%BA%A6%E6%97%8B%E8%BD%AC/"/>
    <id>/2019/08/02/java计算坐标绕另一个坐标任意角度旋转/</id>
    <published>2019-08-01T22:05:29.000Z</published>
    <updated>2019-08-07T05:47:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前做过一个业务需要对图片上某个坐标点进行旋转，于是找了很多资料，大多都是直接旋转图片的，后来终于得一算法，计算得很准确；在此献给大家，可以直接使用！</p><a id="more"></a><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><pre><code> /** * 此函数为旋转坐标算法 * @param p 为需要旋转的坐标点  java.awt.geom.Point2D.Double 属性有:  public double x; public double y * @param pCenter 为围绕点    p坐标将以该坐标为原点进行旋转 * @param angle 为旋转角度  可以为任意角度 * @return 旋转结果 */ public static Point2D.Double rotatePoint(Point2D.Double p, Point2D.Double pCenter, double angle) {    float l = (float) ((angle * Math.PI) / 180);    float cosv = (float) Math.cos(l);    float sinv = (float) Math.sin(l);    float newX = (float) ((p.x - pCenter.x) * cosv - (p.y - pCenter.y) * sinv + pCenter.x);    float newY = (float) ((p.x - pCenter.x) * sinv + (p.y - pCenter.y) * cosv + pCenter.y);    return new Point2D.Double((double) newX, (double) newY);}</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试如下图所示:</p><p><img src="/2019/08/02/java计算坐标绕另一个坐标任意角度旋转/rotatePointTest.jpg" alt="测试图片"></p><p>测试函数</p><pre><code>public static void main(String[] args) {    // 需要旋转的坐标点  这里以像素代替坐标 方便测试    Point2D.Double p = new Point2D.Double(500,200);    // 围绕坐标，这里以图片中心点为例 图片大小为 h :1020px , w : 1020px    Point2D.Double pCenter = new Point2D.Double(1020 / 2d, 1020 / 2d);    // 旋转结果    System.out.println(p + &quot; 绕图片中心点旋转10度为: &quot; + rotatePoint(p,pCenter,10d));    System.out.println(p + &quot; 绕图片中心点旋转20度为: &quot; + rotatePoint(p,pCenter,20d));    System.out.println(p + &quot; 绕图片中心点旋转90度为: &quot; + rotatePoint(p,pCenter,90d));}</code></pre><p>计算结果如下：</p><p><img src="/2019/08/02/java计算坐标绕另一个坐标任意角度旋转/result.jpg" alt="计算结果"></p><p>使用画图工具将图片旋转以检验结果！以90度为例。（因为画图工具只能旋转90的倍数，哈哈！）截图截不到鼠标的位置，小伙伴们时间充裕的话可以自己试试哦！</p><p><img src="/2019/08/02/java计算坐标绕另一个坐标任意角度旋转/rotateResult.jpg" alt="旋转90度结果"></p><p>90度还不足以能看出来效果？那再看看旋转10度！使用在线ps工具</p><p><img src="/2019/08/02/java计算坐标绕另一个坐标任意角度旋转/rotate10Result.jpg" alt="旋转10度结果"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过上面的测试检测，计算还是非常精确的！小伙伴们可以放心使用哦！</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>上面演示的是坐标像素绕中心坐标旋转，小伙伴可以根据自己的需求变换，函数第二的参数pCenter为围绕坐标。</p><p>画图工具以及在线ps工具的0，0位置在左上角，如果0，0位置在其他位置的则需要换算一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前做过一个业务需要对图片上某个坐标点进行旋转，于是找了很多资料，大多都是直接旋转图片的，后来终于得一算法，计算得很准确；在此献给大家，可以直接使用！&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="/tags/java/"/>
    
      <category term="算法" scheme="/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="坐标旋转" scheme="/tags/%E5%9D%90%E6%A0%87%E6%97%8B%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>我的博客</title>
    <link href="/2019/07/30/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>/2019/07/30/我的博客/</id>
    <published>2019-07-30T11:31:58.000Z</published>
    <updated>2019-08-07T06:03:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>从今天开始，咱也是有自己博客的人啦。哈哈！以前一直想弄，却没有弄的博客，今天终于正式启动了。开发的时间过得是飞快的，很快一天过去了，只是弄了一些主题、样式、效果之类的。<a id="more"></a>大多时间都在纠结，想想要说些啥，好歹也是处女篇博客，不写点有深度的东西总感觉不是那么的完美。但是又不知道要写点什么好，犹豫良久，终于纠结癌上头，血压瞬间1800，得赶紧歇着了。得！还是啥也没写。洗洗睡了！毕竟，小命才是最重要的！！</p><h3 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h3><blockquote><p>以前逛别人的博客，经常会看到一些好的文章，让人有种 豁然开朗，茅塞顿开的感觉。当局者迷，很多时候，我们会把自己逼进死胡同，换个角度看问题。其实并没有那么复杂。言归正传，为什么没写过博客。 一 是害怕自己学艺不精，误人子弟，瞻前顾后，不敢作为！二 是嫌麻烦， 有时候确实是没有时间，但大多时候确是懒惰在作怪！三 很多东西，只有自己去试过了才知道到底怎么样。毕竟自己经历过，吹牛皮的时候声音都可以大一点嘛。四 学新技术的时候，很多时候一个很小的问题，可以耗费很长时间，直接写笔记方便又省时。后来释怀了，只有做过才知道行不行。人不能总是逃避问题，给自己找借口不是。</p></blockquote><h3 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h3><blockquote><p>一个苦逼的程序猿，主攻 java 开发，工作多，没提成。别人休假我加班。房贷没还清，保险自己缴，不过好在我不用交停车费，因为我根本买不起车。也没有啥成就。其他的就不多介绍了，毕竟也不是个相亲网站，说多了天上也不会掉媳妇！</p></blockquote><h3 id="关于内容"><a href="#关于内容" class="headerlink" title="关于内容"></a>关于内容</h3><blockquote><p>跟 java 相关的一些资料、笔记，以方便自己查阅，如果有人能从中得到些许收获，我无疑是非常开心的！学海无涯，不当之处，也希望能被指正出来。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从今天开始，咱也是有自己博客的人啦。哈哈！以前一直想弄，却没有弄的博客，今天终于正式启动了。开发的时间过得是飞快的，很快一天过去了，只是弄了一些主题、样式、效果之类的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
